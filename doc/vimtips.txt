最佳vim技巧
----------------------------------------
# 信息来源
----------------------------------------
www.vim.org         : 官方站点
comp.editors        : 新闻组
http://www.newriders.com/books/opl/ebooks/0735710015.html : Vim书籍
http://vimdoc.sourceforge.net/cgi-bin/vim2html2.pl : 关于vim的可查询文档
http://vimdoc.sourceforge.net/vimfaq.html          : VIM FAQ
----------------------------------------
# 基础
----------------------------------------
* # g* g#           : 寻找光标处的狭义单词(<cword>) (前向/后向)
%                   : 括号配对寻找 {}[]()
matchit.vim         : 使得 % 能够配对标记 <tr><td><script> <?php 等等
<C-N><C-P>          : 插入模式下的单词自动完成
<C-X><C-L>          : 行自动完成(超级有用)
/<C-R><C-W>         : 把狭义单词 <cword> 写到 搜索命令 行
/<C-R><C-A>         : 把广义单词 <cWORD> 写到 搜索命令 行
:set ignorecase     : 搜索时忽略大小写
:syntax on          : 在 Perl,HTML,PHP 等中进行语法着色
:h regexp<C-D>      : 按下 control-D 键即可得到包含有 regexp 的帮助主题的列表
                    : (使用TAB可以实现帮助的自动补齐)
----------------------------------------
# 使更新 _vimrc 更容易
:nmap ,s :source $VIM/_vimrc # 译释：nmap 是绑定一个在normal模式下的快捷键
:nmap ,v :e $VIM/_vimrc
# 译释：在normal模式下，先后按下 ,s 两个键执行_vimrc，而 ,v 则是编辑_vimrc
----------------------------------------
# visual 模式 (例子是：轻松添加其他的 HTML Tags)
:vmap sb \"zdi<b><C-R>z</b><ESC>  :在visual模式下选中的文字前后分别加上<b>和</b>
# 译释：vmap 是绑定一个在visual模式下的快捷键\r\n# 译释：原理：在visual模式下，# 译释：原理：在visual模式下，\"zd 把一个选中的区域命名为z 然后删除，
# i 进入插入模式，输入<b>，<C-R>z 撤销刚才的删除,然后再写入</b>，
# 最后<ESC>返回normal模式\r\n# 译释：\"z 命令创建一个选中的区域为register，并把它命名为z\r\n# 译释：更令人开心的有：在visual模式下选中几行，然后输入 2> ,
#       则选中的行会全部缩进两个tab
#       555,偶一开始还是用 :xx,xx s/^/\\t\\t/，好傻啊！\r\n:vmap st \"zdi<?= <C-R>z ?><ESC>  :在visual模式下选中的文字前后分别加上<?= 和 ?>
----------------------------------------
# 文件浏览
:Ex                             : 开启目录浏览器，注意首字母E是大写的
:Sex                            : 在一个分割的窗口中开启目录浏览器
:ls                             : 显示当前buffer的情况
:cd ..                          : 进入父目录
:args                           : 显示目前打开的文件
:lcd %:p:h                      : 更改到当前文件所在的目录
# 译释：lcd是紧紧改变当前窗口的工作路径，% 是代表当前文件的文件名,
# 加上 :p扩展成全名（就是带了路径），加上 :h析取出路径\r\n:autocmd BufEnter * lcd %:p:h   : 自动更改到当前文件所在的目录
# 译释：autocmd指定一个自动命令，BufEnter指定一个事件，* 指定事件的对象，
# lcd %:p:h 指定一个动作
# hehe,好像和写记叙文差不多
----------------------------------------
# 缓冲区(buffer)浏览器 (第三方的一个最流行的脚本)
# 需要下载 bufexplorer.vim ，http://www.vim.org/script.php?script_id=42 上就有
\\be                             : 在缓冲区浏览器中打开缓冲区列表
\\bs                             : 以分割窗口的形式打开缓冲区浏览器
----------------------------------------
# 大小写转换
guu                             : 行小写
gUU                             : 行大写
g~~                             : 行翻转（当然指大小写啦）
# 译释： g 是大小写转换命令(greate)，u/U/~是三种转换形式(小写/大写/翻转)，
# 最后一个重复则表示该转换是对于一行而言的\r\nguw                             : 字大写(狭义字) 译注：建议对比iw
gUw                             : 字小写(狭义字)
g~w                             : 字翻转(狭义字)
# 译释：最后一个w 表示该转换是对于一个字而言的，由于是在normal模式下，
# 所以这个w 表示一个狭义字<cword>\r\nvEU                             : 字大写(广义字)
vE~                             : 字翻转(广义字)
# 译释：vE 这个指令组合会进入visual模式，然后选择一个广义字<CWORD>\r\nggguG                           : 把整个文章全部小写（ft!bt!）
gf                              : 取当前光标处的广义字作为文件名，然后试图打开它！
# 译释：为什么是广义字呢？因为这样可以方便的取到路径啊，像/var/www/html/index.htm\r\nga                              : 显示光标处字符的ascii,hex,oct,...晕菜的一堆转换
ggVGg?                          : 用rot13编码整个文件（晕！）
# 译释：gg到文件首行首字符，V进入Visual-Line模式，G到文件末行首字符，
#       这样就选中了整篇文章，然后g?就是用rot13编码整个文件啦
#
# 【关于rot13――谁让英文是偶数个字母啊】
# ROT13 是一种简单的编码，它把字母分成前后两组，每组13个，编码和解码
# 的算法相同，仅仅交换字母的这两个部分，即：[a..m] --> [n..z] 和 [n..z]
# --> [a..m] 。 ROT13 用简易的手段使得信件不能直接被识别和阅
# 读，也不会被搜索匹配程序用通常的方法直接找到。经常用于 USENET 中发表一
# 些攻击性或令人不快的言论或有简单保密需要的文章。
# 由于 ROT13 是自逆算法，所以，解码和编码是同一个过程。\r\n<C-A>,<C-X>                     : 增加,减少 光标处的狭义字所表示的数字
                                :（,仅仅是分割了这两个命令，不是命令的一部分）
                                : Win32的用户可能需要重新定义一下Ctrl-A，呵呵
# 译注：good guy, 令人不得不想到perl的数字串\r\n<C-R>=5*5                       : 插入25 (这是一个迷你计算器耶！)
----------------------------------------
# 好玩的东东
:h 42            : 也可以访问 http://www.google.com/search?q=42
                 : 第一个结果就是 News. Douglas Adams 1952 - 2001.
                 : Floor 42 extends its deepest sympathies to
                 : the family, friends, and fans of Douglas Adams.
:h holy-grail
:h!
----------------------------------------
# 标记和移动
\'.               : 跳到最后修改的那一行 (超级有用)(ft,怎么又是这个评价)
`.               : 不仅跳到最后修改的那一行，还要定位到修改点
<C-O>            : 依次沿着你的跳转记录向回跳 (从最近的一次开始)
<C-I>            : 依次沿着你的跳转记录向前跳
:ju(mps)         : 列出你跳转的足迹
:help jump-motions
:history         : 列出历史命令记录
:his c           : 命令行命令历史
:his s           : 搜索命令历史
q/               : 搜索命令历史的窗口
q:               : 命令行命令历史的窗口
:<C-F>           : 历史命令记录的窗口
----------------------------------------
# 缩写和键盘映射(原文中文件举例都用了c:/aaa/x，偶全给他改成/path/file了，哼唧)
:map   <f7>   :\'a,\'bw! /path/file
# 译释：map是映射一个normal模式下的键
# 这里是把F7键映射成把标记a到标记b中间的内容另存为一个文件/path/file
# 标记(mark)的方法：把光标移动到需要标记的地方，输入m，然后输入标记名，例如a\r\n# 引用标记的方法：\'a ，即：单引号加标记名\r\n:map   <f8>   :r /path/file # 译释：把F8键映射成在当前位置插入文件/path/file的内容
:map   <f11>  :.w! /path/file2<CR>
# 译释：.（点号）表示当前行
# 所以F11就是把当前行存为/path/file2
# 最后的<CR>表示一个回车
:map   <f12>  :r /path/file2<CR>
:ab php          : 列出php表示的缩写
# 译释：定义一个缩写使用：:iab hm hmisty
# 一个有趣的现象是，它列出的会是php和它的前子串开头的缩写
# 例如，有这么几个缩写：
# h => hmisty1 , hm => hmisty2 , hmi => hmisty3, m => hmisty4
# 那么使用 :ab hm会显示这么几个缩写：hm 和 h
# 而不是你想象中的 hm 和 hmi\r\n:map ,           : 列出以逗号开始的键盘映射
# 译释：一般而言，我们称这些逗号开始的组合键为“逗号命令”
# 不过hmisty更喜欢用;构成“分号命令”
# 而且不是用map,而是用imap
# 因为偶懒么，懒得按<Esc>,所以直接在insert模式下就执行命令了
# 为什么用分号呢？因为我最常用它写程序啊
# perl/C/C++/object pascal/java，都是用分号结束一个语句
# 我们一般很少在分号后面连续写其他字符
# 所以用“分号＋其他键”就很少会在输入的时候造成冲突\r\n# 在键盘映射中常用的表示
<CR>             : 回车
<ESC>            : Esc
<LEADER>         : 转义符号 \\
<BAR>            : 管道符号 |
----------------------------------------
# 列出寄存器(Registers)
:reg             : 显示所有当前的registers
\"1p              : \"表示引用register，1表示一个名字叫做1的register，
                 : p就是粘贴（paste）命令
# 译释：\"也用来定义register
# 先输入 \",表示定义register
# 然后输入名字，如0~9,a~z
# 然后执行删除或复制命令，如dd或y，
#         或者是visual模式下的d(删除选中的部分)或y(复制选中的部分)
# 则被删除或复制的部分就被存入了这个命名的register
#
# 观察：一个特殊的register, \"\" ，里面存储了一个匿名的删除/复制
# 在你执行dd或y的时候，被作用的部分被存到了\"\"中
# 这些和perl是多么像啊
----------------------------------------
# Useful trick
\"ayy@a           : 把当前行作为一个Vim命令来执行
# 译释：\"ayy 是定义当前行到register a，然后@a是执行register a中存储的指令
# yy: 复制一行
# 10yy: 复制从此向下的10行\r\nyy@\"             : 用上面所提到的那个匿名register
----------------------------------------
# 从其他程序获取输出 (需要外部程序)
:r!ls.exe        : 读取ls的输出到当前位置
!!date           : 读取date的输出 (但是会替换当前行的内容)
# 译释：其实你输入了!!后，vim就自动转换到 :.! 等待你继续输入\r\n# 使用外部程序sort进行排序(sort是Unix标准命令，ls,date也是)
:%!sort -u       : 使用sort程序排序整个文件（用结果重写文件）
# 译释：%表示整个文件的所有行
# !sort表示执行外部命令sort
# -u是sort的参数，man sort看看，这个参数的意义是合并相同的行
# u就是unique,如果两行内容相同，则结果中只保留一行的说\r\n:\'a,\'b!sort -u   : 对mark a 到mark b中间的内容进行排序
!1} sort -u      : 排序当前段落 (只能在normal模式下使用!!)
# 译释：!表示使用filter，1}表示filter的对象是从当前行开始向后数一段
# 段落指到空行处结束，不包括空行
# 其实你一旦输入 !1}，vim就自动计算当前段落应该到那一行(eg.+5)，然后生成
# :.,.+5! 等待之后输入sort -u，回车，完成操作
# .表示当前行，.+5当然就是当前行向后数5行
----------------------------------------
# 多文档操作 (基础)
# 译注：用 :ls! 可以显示出当前所有的buffer
:bn              : 跳转到下一个buffer
:bp              : 跳转到上一个buffer
:wn              : 存盘当前文件并跳转到下一个(又是“超级……”,ft!)
:wp              : 存盘当前文件并跳转到上一个
:bd              : 把这个文件从buffer列表中做掉
:bun             : 卸掉buffer (关闭这个buffer的窗口但是不把它从列表中做掉)
:badd file.c     : 把文件file.c添加到buffer列表
:b 3             : 跳到第3个buffer
:b main          : 跳到一个名字中包含main的buffer,例如main.c               : (ultra，这个怎么翻译？:()
:sav php.html    : 把当前文件存为php.html并打开php.html
:sav! %<.bak     : 换一个后缀保存
:e!              : 返回到修改之前的文件(修改之后没有存盘)
:w /path/%       : 把文件存到一个地儿
:e #             : 编辑标记为#的buffer(这个buffer必须含有一个可编辑的文件)
                 : 用ls命令就能看到哪一个buffer有#
                 : %a表示当前正在编辑的buffer
                 : u 表示不能编辑或者已经被做掉的buffer
:e #3            : 编辑编号为3的buffer(这个buffer必须含有一个可编辑的文件)
:rew             : 回到第一个可编辑的文件
:brew            : 回到第一个buffer
:sp fred.txt     : 在一个水平分割的窗口中打开文件fred.txt # 译注：vs fred.txt可以实现垂直分割
:sball           : 把当前所有含有可编辑文件的buffer显示到一个分割窗口中              : (偶该考虑把super翻译成 高级指令 了,ft)
:map   <F5> :ls<CR>:e # : 在normal模式下按F5键，则会显示所有含有一个\r\n                 : 可编辑文件的buffer，然后提示你输入buffer的序号，
                 : 输入后回车，则编辑这个buffer
# 译注：这是一个键盘绑定\r\n:set hidden      : 允许不保存buffer而切换buffer (w/o=without)
----------------------------------------
# 在分割窗口中快速切换
:map <C-J> <C-W>j<C-W>_
# 译注：原文此处有误，前面应该加上冒号
# 这是一个键盘绑定，把Ctrl-J定义成切换到下一个窗口并最大化
:map <C-K> <C-W>k<C-W>_
----------------------------------------
# 命令录制 (最佳技巧，ft)
qq  #录制到q
.. #输入一系列复杂的指令
q   #再次按q停止录制
@q  #执行q中存储的指令
@@  #重复执行
# 编辑register/录制
\"ap #把register a中的内容贴到当前位置
.. #现在你可以修改它了
\"add#删除之，重新存入register a
@a  #执行register a中的指令
----------------------------------------
# _vimrc基础
:set incsearch                        : 实时匹配你输入的内容
:set wildignore=*.o,*.obj,*.bak,*.exe : tab键的自动完成现在会忽略这些
:set shiftwidth=4                     : 现在自动缩进将是4个字符
# 译注：一个tab位通常是8个字符
# 所以，我们还要设定 :set tabstop=4，这样，所有的缩进都是4字符了
# emacs默认就是4字符缩进吧？
:set vb t_vb=\".                        : 沉默方式(不要叫beep！)
----------------------------------------
# 加载windows iexplorer来浏览(我想这只有在windows下用gvim才能用到)
:nmap ,f :update<CR>:silent !start c:\\progra~1\\intern~1\\iexplore.exe file://%:p
# 译释：nmap是做一个normal模式下的键盘绑定
# 这里绑定了一个逗号命令 ,f
# :update是写这个文件，与:w不同，它只有当文件被修改了的时候才写
# :silent别让弹出窗口报告执行结果
# !...后面就是执行windows命令了。呵呵，去问bill gates什么意思吧。
# 不过偶用gvim 6.1试过了，好用！\r\n:nmap ,i :update<CR>: !start c:\\progra~1\\intern~1\\iexplore.exe <cWORD><CR>
----------------------------------------
# 用VIM编辑ftp文件
:cmap ,r  :Nread ftp://209.51.134.122/public_html/index.html
:cmap ,w  :Nwrite ftp://209.51.134.122/public_html/index.html
# 译注：原文丢失了开头的冒号
# cmap是命令(command)模式绑定\r\ngvim ftp://209.51.134.122/public_html/index.html
# 这一句就是开始编辑一个ftp远端的文件，ft
----------------------------------------
# 附加到一个register (就是用大写的register名字啦！)
\"a5yy #复制5行到a中
10j   #下移10行
\"A5yy #再添加5行到a中
----------------------------------------
[I     : 显示光标处的狭义字可以匹配的行(高级指令)
# 译注：# 可以全文查找与光标处的狭义字相匹配的字，
# 这在查找函数原型和实现，或者变量使用的时候很有用
----------------------------------------
# 常规缩进
:\'a,\'b>>
# 译释：把mark a到mark b之间的内容进行两次缩进\r\n# 在visual模式下缩进 (无限可重复)
:vnoremap < <gv
# 译释：:vnoremap 重定义了visual模式下 < 符号的含义
# 把它定义成 <gv
# 即：先<向外缩进，然后gv重新选择上一次选择了的区域
# 这样在visual模式下就可以实现连续按<而连续缩进了
:vnoremap > >gv
# 同里，内缩
----------------------------------------
# 查找（译注：建议先学习正则表达式）
# 译注：查找命令不用进入:命令模式，直接按/就可以了
# 如果没有修饰，可以不要右边的/
# 和smth bbs差不多啦，呵呵
/joe/e                      : 光标停留在匹配单词最后一个字母处
/joe/e+1                    : 光标停留在匹配单词最后一个字母的下一个字母处
/joe/s                      : 光标停留在匹配单词第一个字母处
/^joe.*fred.*bill/          : ft,标准正则表达式
/^[A-J]\\+/                  : 找一个以A~J中一个字母重复两次或以上开头的行
/forum\\(\\_.\\)*pent          : 多行匹配
/fred\\_s*joe/i              : 中间可以有任何空白，包括换行符\\n
# 译注：这个和perl不太一样的哦
/fred\\|joe                  : 匹配FRED或JOE
/\\<fred\\>/i                 : 匹配fred,fred必须是一个独立的单词，而不是子串
# 译注：这和perl也不太一样，perl是用\\b做单词定界符的
/\\<\\d\\d\\d\\d\\>               : 匹配4个数字
\\<\\d\\{4}\\>                  : 也是匹配4个数字
# 在visual模式下查找
:vmap g/ y/<C-R>\"<CR>       : 匹配选中的高亮文字
# 译释：vmap是在visual模式下的键盘映射
# 映射了g/这个命令组合
# y 把选中的高亮文字写入匿名register \"
# / 打开搜索模式
# <C-R> 准备粘贴register
# \" 粘贴了\"\"中的内容
# <CR> 回车，执行\r\n:vmap <silent> g/    y/<C-R>=escape(@\", \'\\\\/.*$^~[]\')<CR><CR> : with spec chars
# 译释：@#$&^*@#%&*#$@!\r\n# 跨行匹配，\\_ 表示允许匹配换行符，或者说，允许匹配新行
# 译注：小心，和perl不一样
/<!--\\_p\\{-}-->                   : 匹配多行注释
/fred\\_s*joe/i                    : 似乎上面有了，ft
/bugs\\(\\_.\\)*bunny                : 中间可以有无数东西
:h \\_                             : 看看关于 \\_ 的帮助\r\n# 查找当前光标位置所在子例程/函数(subroutine/function)的声明
:nmap gx yiw/^\\(sub\\<bar>function\\)\\s\\+<C-R>\"<CR>
# 译释：nmap 做一个normal模式下的键盘绑定
# y 进入复制状态，后面需要一个motion
# 接着就用 iw 指出了这个motion,是inner word
# inner word也是狭义字<cword>，但是和 w 不同
# w 是从光标位置开始向后看
# 而inner word总是把光标移到第一个字母，从而总能得到一个完整的狭义字
# 试一试 gUw 和 gUiw 就知道区别了，呵呵。\r\n# 在多个文档中搜索
:bufdo /searchstr
:argdo /searchstr
----------------------------------------
# 替换
# 译注：替换命令需要先进入:命令模式\r\n:%s/fred/joe/igc            : 一个常见的替换命令，修饰符igc和perl中一样意思
:%s/\\r//g                   : 删除DOS方式的回车^M
:%s=  *$==                  : 删除行尾空白
:\'a,\'bg/fred/s/dick/joe/igc : 非常有用！（ft,又来了！）
# 译释：\'a,\'b指定一个范围：mark a ~ mark b
# g//用一个正则表达式指出了进行操作的行必须可以被fred匹配
# 看后面，g//是一个全局显示命令
# s/dick/joe/igc则对于这些满足条件的行进行替换\r\n# 列复制
# 译注：@#%&^#*^%#$!
:%s= [^ ]\\+$=&&=            : 复制最后一列
:%s= \\f\\+$=&&=              : 一样的功能
:%s= \\S\\+$=&&               : ft,还是一样 # 反向引用，或称记忆
:s/\\(.*\\):\\(.*\\)/\\2 :  \\1/  : 颠倒用:分割的两个字段
:%s/^\\(.*\\)\\n\\1/\\1$/        : 删除重复行 # 非贪婪匹配，\\{-}
:%s/^.\\{-}pdf/new.pdf/      : 只是删除第一个pdf # 跨越可能的多行
:%s/<!--\\_.\\{-}-->//        : 又是删除多行注释（咦？为什么要说“又”呢？）
:help /\\{-}                 : 看看关于 非贪婪数量符 的帮助
:s/fred/<c-r>a/g            : 替换fred成register a中的内容，呵呵 # 写在一行里的复杂命令
:%s/\\f\\+\\.gif\\>/\\r&\\r/g | v/\\.gif$/d | %s/gif/jpg/
# 译注：就是用 | 管道啦\r\n# 或者
:%s/suck\\|buck/loopy/gc     : 或者(或者需要\\，ft！，|不是或者)
# ft, \\不就是转义了么！这个和perl真是不同了！\r\n# 调用VIM函数
:s/__date__/\\=strftime(\"%c\")/ : 插入时间串\r\n# 处理列，替换所有在第三列中的str1
:%s:\\(\\(\\w\\+\\s\\+\\)\\{2}\\)str1:\\1str2:\r\n# 交换第一列和最后一列 (共4列)
:%s:\\(\\w\\+\\)\\(.*\\s\\+\\)\\(\\w\\+\\)$:\\3\\2\\1:\r\n# filter all form elements into paste register
# 把所有的form元素（就是html里面的form啦）放到register里？
# ft, 头疼，不解释了
:redir @*|sil exec \'g#<\\(input\\|select\\|textarea\\|/\\=form\\)\\>#p\'|redir END
:nmap ,z :redir @*<Bar>sil exec select\\textarea\\/\\=fo\">\'g@<\\(input\\<Bar>select\\<Bar>textarea\\<Bar>/\\=fo
# 上面这一行不能完全显示，最好Copy Article下去看\r\n----------------------------------------
# 全局(global)显示命令，就是用 :g＋正则表达式
# 译释： :g/{pattern}/{cmd} 就是全局找到匹配的行
# 然后对这些行执行命令{cmd}
:g/\\<fred\\>/                : 显示所有能够为单词fred所匹配的行
:g/<pattern>/z#.5           : 显示内容，还有行号，呵呵
:g/<pattern>/z#.5|echo \"==========\"  : 漂亮的显示，ft!\r\n# 全局命令 (其他)
:g/^\\s*$/d                  : 删除所有空行
:g!/^dd/d                   : 删除不含字串\'dd\'的行
:v/^dd/d                    : 同上 # 译释：v == g!，就是不匹配！
:g/fred/,/joe/d             : not line based (very powerfull)
:v/./.,/./-1join            : 压缩空行
:g/^$/,/./-j                : 压缩空行
:g/<input\\|<form/p          : 或者 要用\\|
:g/^/pu _                   : 把文中空行扩增一倍 (pu = put)                         : 即：原来两行间有一个空行，现在变成2个
:g/^/m0                     : 按行翻转文章 (m = move)
:g/fred/t$                  : 拷贝行，从fred到文件末尾(EOF)
:%norm jdd                  : 隔行删除
# 译释：% 指明是对所有行进行操作
# norm指出后面是normal模式的指令
# j是下移一行，dd是删除行\r\n# incrementing numbers
:.,$g/^\\d/exe \"norm! \\<c-a>\" : 增加在BOL(beginning of line)处的数字
# 译注：.,$ 指明命令从当前行执行到最后一行
# 如果没有 .,$ 限定范围，那么g//就会对整个文件进行操作
# exe 是执行后面的命令组合\r\n:.,$g/^\\d/exe \"norm \\<c-p>\"  : Win32下必须重定义Ctrl-A\r\n# 保存全局命令的结果 (注意必须使用添加模式)
:g/fred/y A                 : 添加所有为fred所匹配的行到register a
:\'a,\'b g/^Error/ . w >> errors.txt\r\n# 复制每一行，然后在复制出来的每一行两侧加上一个 print \'复制出来的内容\'
:g/./yank|put|-1s/\'/\"/g|s/.*/Print \'&\'/
----------------------------------------
# 全局命令和替换命令联姻 (强大的编辑能力)
:\'a,\'bg/fred/s/joe/susan/gic : 可以使用反向引用来匹配
:g/fred/,/joe/s/fred/joe/gic :  non-line based (ultra)
----------------------------------------
# 先找fred，然后找joe，然后#$^$%^#$%^@%^%&%^*!
:/fred/;/joe/-2,/sid/+3s/sally/alley/gIC
----------------------------------------
# 重定向到register * 和 粘贴register *
:redir @*                    : 重定向命令的输出结果（最下方命令行上的结果）                          : 到register * (ft,* 代表0~1,a~z,..)
:redir END                   : 结束重定向
# 处理粘贴
\"*yy                         : 上面讲过了，就是复制到register *中
\"*p                          : 然后贴出来
----------------------------------------
:redir >> out.txt            : 重定向到一个文件
----------------------------------------
# 重新格式化文本
gq<CR>
gqap  (a是motion p是段落(visual模式))
ggVGgq  重新格式化整个文章
----------------------------------------
# 对多个文档实施命令
:argdo %s/foo/bar/           : 对所有:args列表中的文档执行命令
:bufdo %s/foo/bar/
:windo %s/foo/bar/
:argdo exe \'%!sort\'|w!       : 使用外部命令
----------------------------------------
# 命令行的一些好玩的东东
gvim -h                    : 启动的时候启动帮助(Win32)
vi -h 或 vim -h            : 这个是unix下用
ls | gvim -                : 编辑一个数据流！
gvim -o file1 file2        : 以分割窗口打开两个文件\r\n# 指出打开之后执行的命令
gvim.exe -c \"/main\" joe.c  : 打开joe.c，然后跳转到\'main\'\r\n# 对一个文件执行多个命令
vim -c \"%s/ABC/DEF/ge | update\" file1.c\r\n# 对一组文件执行多个命令
vim -c \"argdo %s/ABC/DEF/ge | update\" *.c\r\n# 自动编辑文件 (编辑命令序列Ex commands已经包含在convert.vim中了)
vim -s \"convert.vim\" file.c\r\n# 不要加载.vimrc和任何plugins (启动一个干净的VIM)
gvim -u NONE -U NONE -N
----------------------------------------
# GVIM 不同的地方
gvim -d file1 file2        : vimdiff (比较不同)
dp                         : 把光标处的不同放到另一个文件
do                         : 在光标处从另一个文件取得不同
----------------------------------------
# Vim陷阱
# 在vim的正则表达式中， + 和 | 都必须加转义符 \\
# 小心，这和perl不一样！
/fred\\+/      : 匹配fred或freddy但是不匹配free
----------------------------------------
# \\v ，或叫做very magic (通常都是这么叫)可以取消转义符
/codes\\(\\n\\|\\s\\)*where  : 普通的正则表达式
/\\vcodes(\\n|\\s)*where   : very magic，| 不用加 \\ 了！\r\n----------------------------------------
# 把东西送到命令行/搜索行 (SUPER:偶不再翻译这种叹词了)
<C-R><C-W>              : 送一个狭义词
<C-R><C-A>              : 送一个广义词
<C-R>-                  : 送一个小型删除寄存器register
<C-R>[0-9a-z]           : 送一个命名寄存器register
<C-R>%                  : 送文件名过去 (#也行)
----------------------------------------
# 操作寄存器
:let @a=@_              : 清除register a
:let @*=@a              : 寄存器赋值
:map   <f11> \"qyy:let @q=@q.\"zzz\"
# 译注：猜猜这个无聊的绑定是什么意思？
----------------------------------------
# 关于帮助的帮助
:h quickref             : 翻到VIM Quick Reference页(有用！)
:h tips                 : Vim自己的tips
:h visual<C-D><tab>     : 得到一个关于visual关键字的帮助列表                     : 然后用tab键去选择
:h ctrl<C-D>            : 显示所有关于Ctrl的帮助
:h :r                   : :ex冒号命令
:h CTRL-R               : 普通模式命令
:h \\r                   : \\r在正则表达式中是什么意思呢？
:h i_CTRL-R             : insert模式下的Ctrl-R
:h c_CTRL-R             : 命令行(command-line)模式下的Ctrl-R
:h v_CTRL-V             : visual模式下的Ctrl-V
:h tutor                : VIM 指南
gvim -h                 : 关于 VIM 命令的帮助
vi/vim -h
<C-S>T                  : Control Shift T go backwards in help
                        : 偶不清楚有什么用:(
----------------------------------------
# 选项设置在哪里？
:scriptnames            : 列出所有加载的 plugins, _vimrcs
:verbose set history    : 显示history的值并指出设置文件的位置
----------------------------------------
# 制作你自己的VIM帮助
:helptags /vim/vim61/doc  : 重建 /doc 中所有的 *.txt 帮助文件
:help add-local-help
----------------------------------------
# 用外部程序来运行程序 (例如 perl :)
map   <f2>   :w<CR>:!perl -c %<CR>
# 译释：:w<CR>写文件
# :!perl -c %<CR>用perl来运行当前文件
# 当前文件必须有文件名！
----------------------------------------
# 插入DOS换行符
:%s/nubian/<C-V><C-M>&/g          :  Ctrl-V是一种转义，它说要解释<C-M>
:%s/nubian/<C-Q><C-M>&/g          :  对于Win32应该这样
:%s/nubian/^M&/g                  :  你看到的^M是一个字符
:%s/nubian/\\r&/g                  :  更好的形式
----------------------------------------
# 把最后一个命令贴到当前位置
i<c-r>:
# 把最后一个搜索指令贴到当前位置
i<c-r>/
# 译释：i是进入insert模式，
# Ctrl-r是开启插入模式下register的引用
# :和/分别引用了两个register的内容
----------------------------------------
# 更多的完成功能
<C-X><C-F>                        :插入当前目录下的一个文件名到当前位置
# 在insert模式下使用
# 然后用 Ctrl-P/Ctrl-N 翻页
----------------------------------------
# 替换一个visual区域
# 选择一个区域，然后输入 :s/Emacs/Vim/ 等等，vim会自动进入:模式
:\'<,\'>s/Emacs/Vim/g               : 前面的\'<,\'>是vim自动添加的
----------------------------------------
# 在文件中插入行号(不是显示行号，是插入！)
:g/^/exec \"s/^/\".strpart(line(\".\").\"    \", 0, 4)
----------------------------------------
# 用VIM的方式来编号行
:set number                       :显示行号
:set nonu                         :取消显示
:%s/^/\\=strpart(line(\'.\').\"        \",0,&ts)\r\n#从任意行开始编号(需要perl，嘿嘿)
:\'a,\'b!perl -pne \'BEGIN{$a=223} substr($_,2,0)=$a++\'
#似乎有点小问题，你试试看:)\r\nqqmnYP`n^Aq                       : 记录到q 然后用 @q 重复
#似乎不能工作，你试试看:)\r\n# 递增已存在数字到文件末
:.,$g/^\\d/exe \"normal! \\<c-a>\"\r\n# 高级递增，看：
http://vim.sourceforge.net/tip_view.php?tip_id=150
----------------------------------------
# 高级递增 (\"真的很有用\"，ft)
\" 把下面几句放到 _vimrc #vimrc脚本用 \" 做行注释符
let g:I=0
function! INC(increment)
let g:I =g:I + a:increment
return g:I
endfunction
\" 例如从mark a 到mark b 递增，从223开始，步长为5
:let I=223
:\'a,\'bs/$/\\=INC(5)/
\" (原文：create a map for INC)
\" 但是cab是清楚命令行缩写啊？怎么回事？
cab viminc :let I=223 \\| \'a,\'bs/$/\\=INC(5)/
----------------------------------------
# 加密(小心使用，不要忘了密码)\r\n:X                                : 然后vim会提示你输入密码
:h :X
----------------------------------------
# modeline (make a file readonly etc) must be in first/last 5 lines
# 不会用，不翻了
// vim:noai:ts=2:sw=4:readonly:
:h modeline
----------------------------------------
# Creating your own GUI Toolbar entry
# 对于text模式下的vim没用，不翻了
amenu  Modeline.Insert\\ a\\ VIM\\ modeline <Esc><Esc>ggOvim:ff=unix ts=4 ss=4<CR>v
----------------------------------------
# 一个保存当前光标下的狭义字到一个文件的函数
function! SaveWord()  \"这里用!是强制覆盖以前的定义
   normal yiw
   exe \':!echo \'.@0.\' >> word.txt\'
endfunction
map ,p :call SaveWord() #使用该函数的一个例子
----------------------------------------
# 删除重复行的函数
function! Del()
 if getline(\".\") == getline(line(\".\") - 1)
   norm dd
 endif
endfunction\r\n:g/^/ call Del() #使用该函数的一个例子
----------------------------------------
# 双字节编码 (non alpha-numerics)
:digraphs                         : 显示编码表
:h dig                            : 帮助
i<C-K>e\'                          : 输入 é
i<C-V>233                         : 输入 é (Unix)
i<C-Q>233                         : 输入 é (Win32)
ga                                : 查看字符的hex值
----------------------------------------
# 文件名自动完成 (例如 main_c.c)
:e main_<tab>                     : tab 键完成
gf                                : 打开光标处广义字命名的文件 (normal模式)
main_<C-X><C-F>                   : 文件名自动完成(insert模式)
----------------------------------------
# Vim复杂使用
# 交换两个单词
:%s/\\<\\(on\\|off\\)\\>/\\=strpart(\"offon\", 3 * (\"off\" == submatch(0)), 3)/g
----------------------------------------
# 把text文件转换成html文件(oh,ft)
:runtime! syntax/2html.vim        : 转换 txt 成 html
:h 2html                          : 看看帮助
----------------------------------------
# VIM 有一个内部自带的 grep 命令
:grep some_keyword *.c            : 得到一个包含some_keyword的c文件名列表
:cn                               : 去下一个出现的位置
----------------------------------------
# 强制无后缀文件的语法着色方式 .pl
:set syntax=perl # 取消语法着色
:set syntax off # 改变色彩主题 (在~vim/vim??/colors中的任何文件)
:colorscheme blue ----------------------------------------
:set noma (non modifiable)        : 防止修改
:set ro (Read Only)               : 只读保护
----------------------------------------
# Sessions (打开一系列文件)
gvim file1.c file2.c lib/lib.h lib/lib2.h :在\"session\"中加载一系列文件
:mksession                        : 生成一个Session文件 (默认是Session.vim)
:q
gvim -S Session.vim               : 重新读取一个session，也就读取了所有文件,ft
----------------------------------------
# 标记(tags) (跳转到subroutines/functions)
taglist.vim                       : 最流行的插件
:Tlist                            : 显示Tags (functions的列表)
<C-]>                             : 跳转到光标处的function
                                  : 这个键 Ctrl-] 和vim帮助中是一样的
----------------------------------------
# Just Another Vim Hacker JAVH
# Juat Another Perl Hacker JAPH，嘿嘿
vim -c \":%s/^/WhfgTNabgureRIvzSUnpxre/|:%s/[R-T]/ /Ig|:normal ggVGg?\"
# 译释：呵呵，谁来解释一下吧！
# 其实不过是在启动vim的时候执行了一个命令
# 先写入了 Just Another Vim Hacker 的rot13编码
# 然后再解码
----------------------------------------
终于翻完了，呵呵。好累啊！
__END__\r\n--
hmisty, hey misty!
H misty
Haow Much I\'m Special To You
vi 剪贴操作补充(一)\r\n强烈建议大家先看看 doc/change.txt 里关于寄存器部分的内容，
 只是简单提及一下，英文不太好的朋友请找 vim 的中文文档。
我要介绍的超强武器是 ctrl-r，在 insert mode
和 command mode 均可使用，功能就是插入寄存器相关内容。
大家可以试试先 copy 或 delete 一些文本，然后在
normal mode 或 command mode 输入 ctrl-r \"，看到了吗，
你粘贴了寄存器\"的内容。\r\n寄存器的主要有以下几种：
a. The unnamed register \"\"
 \"d\", \"c\", \"s\", \"x\" 和 \"y\" 等涉及删除或拷贝的命令
 都会将内容存放于此(有例外)。\r\nb. 10 numbered registers \"0 to \"9
 0 为最近拷贝的内容，1-9 为最近删除的内容。
 指定 named register 时不会存放于此。\r\nc. The small delete register \"-
 删除不多于一行的内容会存在于此。\r\nd. 26 named registers \"a to \"z or \"A to \"Z
 小写与大写的区别是，小写是覆盖方式，大写是添加方式。\r\ne. four read-only registers \":, \"., \"% and \"#
 \". 存放上次插入的文本
 有什么用？呵，例如，你输入了一段文本，在另一个地方也
 要有相同的内容，你输完后，一般要选择并复制一下吧？
 而用这个，直接移到需要插入的地方，i<ctrl-r>. 即可。
 \"% 是当前编辑文件全名
 呵，vim 中，% 就是代表当前编辑文件名的变量，好记吧？
 不过，一般直接用 % 就行，例如\":!cat %\"，vim 会自动
 扩展。
 \"# 是alternate file 名称 (这个我不知道)
 \": 上次执行的命令
 记起来比较容易，冒号就是命令行提示符嘛。这个有些什么用呢？
 在测试配置文件时十分有用，先在命令行输入命令，调试好后，
 在 insert mode 里按Ctrl-R : 就可将该命令插到文件中。\r\nf. the expression register \"=
 呵，表达式寄存器，可以输入一个表达式，并插入结果。\r\ng. The selection and drop registers \"*, \"+ and \"~
 跟 gui 即 X/Windows 剪贴板有关的变量。
 在 X 中，鼠标中键与系统剪贴板不一样，至于区别，大家自己
 试验一下，这里给个提示，在命令行下输入 reg 可以列出所有
 寄存器的内容。
h. The black hole register \"_
 黑洞\r\ni. Last search pattern register \"/
 上次搜索的内容。例如，我要搜索一个单词 linuxforum，但我
 比较懒，先输入 /linux，发现出现很多个 linux，多次按 n 无果，
 难道要重新输入 /linuxforum ? 不用，只需要 /<ctrl-r>/forum 即可。
 呵，聪明的你一定想到了，用命令行历史也可以调来，按 ctrl-p 或 ctrl-n
 即可上下翻阅。这样也可以嘛，也比较快捷，但要查找 forumlinux 呢？
 用 ctrl-r 的话只需 /forum<ctrl-r>/ 。\r\nvim 使用技巧
作者: camry.wu\r\n我是 vim 粉丝, 用了许久, 有一些自己的感受, 又到处挖到一些别人的技巧. 感觉对 vim
粉丝比较有用, 就把它记在这儿. 希望借此文套出大家自己的巧活, 就正应了抛砖引玉的古
话了.\r\n先稍为介绍一下 vim. vi 是 unix/linux 下极为普遍的一种文本编辑器, 大部分机器上都
有. vi 有各种变种, 在不同的机器上常用不同的变种软件. 其中 vim 比较好用也用得比较
广泛. vim 是 Vi IMproved 的缩写, 表示更好的 vi. 我个人觉得它是非常好的编辑器(为
了避免 Emacs 粉丝挑眼, 就不说最好了). 没用过的也建议试试看, 当然 vim 对编写文本
文件很方便好用, 比如编写程序, html文档等等, 却不能用来编写 word 文档.\r\n关于 vim 的安装, 基本使用方法等网络上能搜出许多, 就不在这里罗嗦了, 要是对 vim 有
兴趣, 那就看看这里(中文文档): http://vcd.cosoft.org.cn/pwiki/index.php\r\n本文就说些其中比较有用, 比较常用的命令, 若能熟练运用这些命令, 那么会发现编辑文件
很舒服.\r\n说明:
以下的例子中 xxx 表示在命令模式下输入 xxx 并回车
以下的例子中 :xxx 表示在扩展模式下输入 xxx 并回车
小括号中的命令表示相关命令.
在编辑模式或可视模式下输入的命令会另外注明.\r\n1. 查找\r\n  /xxx(?xxx)      表示在整篇文档中搜索匹配xxx的字符串, / 表示向下查找, ? 表示向上查找.其中xxx可以是正规表达式,关于正规式就不多说了.
一般来说是区分大小写的, 要想不区分大小写, 那得先输入
:set ignorecase
查找到以后, 再输入 n 查找下一个匹配处, 输入 N 反方向查找.\r\n  *(#)            当光标停留在某个单词上时, 输入这条命令表示查找与该单词匹配的
下(上)一个单词. 同样, 再输入 n 查找下一个匹配处, 输入 N 反方
向查找.\r\n  g*(g#)          此命令与上条命令相似, 只不过它不完全匹配光标所在处的单词, 而
是匹配包含该单词的所有字符串.\r\n  gd              本命令查找与光标所在单词相匹配的单词, 并将光标停留在文档的非
注释段中第一次出现这个单词的地方.\r\n  %               本命令查找与光标所在处相匹配的反括号, 包括 () [] {}\r\n  f(F)x           本命令表示在光标所在行进行查找, 查找光标右(左)方第一个x字符.
找到后:
输入 ; 表示继续往下找
输入 , 表示反方向查找\r\n2. 快速移动光标
在 vi 中, 移动光标和编辑是两件事, 正因为区分开来, 所以可以很方便的进行光标定
位和编辑. 因此能更快一点移动光标是很有用的.\r\n  w(e)            移动光标到下一个单词.
  b               移动光标到上一个单词.\r\n  0               移动光标到本行最开头.
  ^               移动光标到本行最开头的字符处.
  $               移动光标到本行结尾处.\r\n  H               移动光标到屏幕的首行.
  M               移动光标到屏幕的中间一行.
  L               移动光标到屏幕的尾行.
  gg              移动光标到文档首行.
  G               移动光标到文档尾行.
  c-f             (即 ctrl 键与 f 键一同按下) 本命令即 page down.
  c-b             (即 ctrl 键与 b 键一同按下, 后同) 本命令即 page up.\r\n  \'\'              此命令相当有用, 它移动光标到上一个标记处, 比如用 gd, * 等查
  找到某个单词后, 再输入此命令则回到上次停留的位置.\r\n  \'.              此命令相当好使, 它移动光标到上一次的修改行.\r\n  `.        此命令相当强大, 它移动光标到上一次的修改点.\r\n3. 拷贝, 删除与粘贴
   在 vi 中 y 表示拷贝, d 表示删除, p 表示粘贴. 其中拷贝与删除是与光标移动命令
结合的, 看几个例子就能够明白了.\r\n  yw              表示拷贝从当前光标到光标所在单词结尾的内容.
  dw              表示删除从当前光标到光标所在单词结尾的内容.
  y0              表示拷贝从当前光标到光标所在行首的内容.

  
  d0              表示删除从当前光标到光标所在行首的内容.
  y$              表示拷贝从当前光标到光标所在行尾的内容.
  d$              表示删除从当前光标到光标所在行尾的内容.
  yfa             表示拷贝从当前光标到光标后面的第一个a字符之间的内容.
  dfa             表示删除从当前光标到光标后面的第一个a字符之间的内容.\r\n  特殊地:
  yy              表示拷贝光标所在行.
  dd              表示删除光标所在行.
  D               表示删除从当前光标到光标所在行尾的内容.\r\n  关于拷贝, 删除和粘贴的复杂用法与寄存器有关, 可以自行查询.\r\n4. 
  
  数字与命令
   在 vi 中数字与命令结合往往表示重复进行此命令, 若在扩展模式的开头出现则表示行
号定位. 如:\r\n  5fx             表示查找光标后第 5 个 x 字符.\r\n  5w(e)           移动光标到下五个单词.\r\n  5yy             表示拷贝光标以下 5 行.
  5dd             表示删除光标以下 5 行.\r\n  y2fa            表示拷贝从当前光标到光标后面的第二个a字符之间的内容.\r\n  :12,24y         表示拷贝第12行到第24行之间的内容.
  :12,y           表示拷贝第12行到光标所在行之间的内容.
  :,24y           表示拷贝光标所在行到第24行之间的内容. 删除类似.\r\n5. 快速输入字符
   在 vi 中, 不要求你输入每一个字符, 可以有很多种方法快速输入一些字符.
   使用 linux/unix 的同学一定有一个经验, 在命令行下输入命令时敲入头几个字符再按
TAB 系统就会自动将剩下的字符补齐, 假如有多个匹配则会打印出来. 这就是著名的命令
补齐(其实windows中也有文件名补齐功能). vi 中有许多的字符串补齐命令, 非常方便.\r\n  c-p(c-n)        在编辑模式中, 输入几个字符后再输入此命令则 vi 开始向上(下)搜
                  索开头与其匹配的单词并补齐, 不断输入此命令则循环查找. 此命令
                  会在所有在这个 vim 程序中打开的文件中进行匹配.\r\n  c-x-l           在编辑模式中, 此命令快速补齐整行内容, 但是仅在本窗口中出现的
                  文档中进行匹配.\r\n  c-x-f           在编辑模式中, 这个命令表示补齐文件名. 如输入:
                  /usr/local/tom 后再输入此命令则它会自动匹配出:
                  /usr/local/tomcat/\r\n  abbr            即缩写. 这是一个宏操作, 可以在编辑模式中用一个缩写代替另一个
                  字符串. 比如编写java文件的常常输入 System.out.println, 这很
                  是麻烦, 所以应该用缩写来减少敲字. 可以这么做:
                  :abbr sprt System.out.println
                  以后在输入sprt后再输入其他非字母符号, 它就会自动扩展为System.
                  out.println\r\n6. 替换
   替换是 vi 的强项, 因为可以用正规表达式来匹配字符串.以下提供几个例子.\r\n  :s/aa/bb/g      将光标所在行出现的所有包含 aa 的字符串中的 aa 替换为 bb
  :s/\\<aa\\>/bb/g  将光标所在行出现的所有 aa 替换为 bb, 仅替换 aa 这个单词
  :%s/aa/bb/g     将文档中出现的所有包含 aa 的字符串中的 aa 替换为 bb
  :12,23s/aa/bb/g 将从12行到23行中出现的所有包含 aa 的字符串中的 aa 替换为 bb
  :12,23s/^/#/    将从12行到23行的行首加入 # 字符
  :%s= *$==       将所有行尾多余的空格删除
  :g/^s*$/d       将所有不包含字符(空格也不包含)的空行删除.\r\n7. 多文件编辑
   在一个 vim 程序中打开很多文件进行编辑是挺方便的.\r\n  :sp(:vsp) 文件名    vim 将分割出一个横(纵)向窗口, 并在该窗口中打开新文件.
                      从 vim6.0 开始, 文件名可以是一个目录的名称, 这样, vim 会
                      把该目录打开并显示文件列表, 在文件名上按回车则在本窗口打
                      开该文件, 若输入 O 则在新窗口中打开该文件, 输入 ? 可以看
                      到帮助信息.\r\n  :e 文件名           vim 将在原窗口中打开新的文件, 若旧文件编辑过, 会要求保存.\r\n  c-w-w               vim 分割了好几个窗口怎么办? 输入此命令可以将光标循环定位
                      到各个窗口之中.\r\n  :ls                 此命令查看本 vim 程序已经打开了多少个文件, 在屏幕的最下方
                      会显示出如下数据:
                      1   %a      \"usevim.html\"         行 162
                      2   #       \"xxxxxx.html\"         行 0\r\n                      其中:
                      1               表示打开的文件序号, 这个序号很有用处.
                      %a              表示文件代号, % 表示当前编辑的文件,
                                      # 表示上次编辑的文件
                      \"usevim.html\"   表示文件名.
                      行 162          表示光标位置.\r\n  :b 序号(代号)       此命令将指定序号(代号)的文件在本窗口打开, 其中的序号(代号)
                      就是用 :ls 命令看到的.\r\n  :set diff           此命令用于比较两个文件, 可以用
                      :vsp filename
                      命令打开另一个文件, 然后在每个文件窗口中输入此命令,就能看
                      到效果了.\r\n8. 宏替换
   vi 不仅可以用 abbr 来替换文字, 也可以进行命令的宏定义. 有些命令输起来很费劲,
因此我把它们定义到 <F1>-<F12> 上, 这样就很方便了.这些配置可以预先写到 ~/.vimrc
(windows 下为 $VIM/_vimrc) 中, 写进去的时候不用写前面的冒号.\r\n  :nmap <F2> :nohls<cr>              取消被搜索字串的高亮
  :nmap <F9> <C-W>w                  命令模式下转移光标到不同窗口
  :imap <F9> <ESC><F9>               输入模式下运行<F9>
  :nmap <F12> :%s= *$==<cr>          删除所有行尾多余的空格.
  :imap <F12> <ESC><F12>             同上\r\n  :java 中: (注, 这里为什么说 java 中, 因为以下定义对其他文件格式不起作用, 下文
            会说到如何实现这一点)
  :nmap <F3> :comp javac<CR>:mak -d . %<CR>
       此命令用 javac 编译 java 文件, 它会自动将光标定位到出错点. 不过这需要定
       义一个 javac.vim 文件在 $VIM/compiler 下, 在 javac.vim 里面只有两行字:
          setlocal makeprg=javac
          setlocal errorformat=%A%f:%l:\\ %m,%-Z%p^,%-C%.%#\r\n  :nmap <F4> :comp ant<CR>:mak<CR>
       此命令用 ant 编译 java 文件, 它会自动将光标定位到出错点. 一般来说, 安装
       vim 后已经有了compiler/ant.vim文件, 因此这个命令可以直接使用. 但是需要
       在当前目录下有 build.xml 文件, 当然还必须安装 ant 才行.\r\n  :nmap <F5> :cl<CR>                 此命令用于查看所有的编译错误.
  :imap <F5> <ESC><F5>\r\n  :nmap <F6> :cc<CR>                 此命令用于查看当前的编译错误.
  :imap <F6> <ESC><F6>\r\n  :nmap <F7> :cn<CR>                 此命令用于跳到下一个出错位置.
  :imap <F7> <ESC><F7>\r\n  :nmap <F8> :cp<CR>                 此命令用于跳到上一个出错位置.
  :imap <F8> <ESC><F8>\r\n  :nmap <F11> :JavaBrowser<cr>
       此命令用于在窗口左部分割出一个新窗口, 里面的内容是 java 的资源树, 包括
       本文件中出现的类, 类的成员变量及成员方法, 就好像 JCreator 表现的那样.
       在这个窗口中输入 ? 会看到帮助. 嘿嘿, 很好用, 不过需要 ctags 支持.
  :imap <F11> <ESC><F11>\r\n9. TAB
   TAB 就是制表符, 单独拿出来做一节是因为这个东西确实很有用.\r\n   <<                  输入此命令则光标所在行向左移动一个 tab.
   >>                  输入此命令则光标所在行向右移动一个 tab.
   5>>                 输入此命令则光标后 5 行向右移动一个 tab.
   :12,24>             此命令将12行到14行的数据都向右移动一个 tab.
   :12,24>>            此命令将12行到14行的数据都向右移动两个 tab.\r\n   那么如何定义 tab 的大小呢? 有人愿意使用 8 个空格位, 有人用4个, 有的用2个.
   有的人希望 tab 完全用空格代替, 也有的人希望 tab 就是 tab. 没关系, vim 能
   帮助你.以下的设置一般也都先写入配置文件中, 免得老敲.\r\n   :set shiftwidth=4   设置自动缩进 4 个空格, 当然要设自动缩进先.
   :set sts=4          即设置 softtabstop 为 4. 输入 tab 后就跳了 4 格.
   :set tabstop=4      实际的 tab 即为 4 个空格, 而不是缺省的 8 个.
   :set expandtab      在输入 tab 后, vim 用恰当的空格来填充这个 tab.\r\n10. autocmd
    这个命令十分的强大, 可以用这个命令实现对不同的文件格式应用不同的配置; 可以
在新建文件时自动添加上版权声明等等. 这些命令一般定义在 ~/.vimrc 这样的配置文件
里面. 由于他很强大, 所以我不能给出很具体的说明, 只能举几个例子, 详细的请看帮助.\r\n  :autocmd!               删除所有之前的自动命令.
  autocmd FileType        java  source ~/.vim/files/java.vim
  autocmd FileType        java  source ~/.vim/files/jcommenter.vim
    以上两条命令让我在打开 java 文件时才应用后面提到的两个配置文件.
  autocmd BufNewFile      *.java  0r ~/.vim/files/skeletons/java.skel
    以上这条命令让我在新建 java 文件时自动加入 java.skel 文件的内容.
  autocmd BufNewFile      *.java  normal gnp
    以上这条命令让我在新建 java 文件时自动运行 gnp 命令, 这个命令进行一些特殊化
    处理, 比如将新 java 文件中的 __date__ 替换成今天的日期什么的.\r\n11. 常用脚本
    在 vim.sf.net 你可以发现很多脚本(script), 这些脚本常常有让你意想不到的作用.
我常用的有:\r\n    jcommenter.vim        自动加入 javadoc 风格的注释.
    JBrowser.vim          类资源浏览. C, C++ 等可以用 Tlist\r\n    还有许多有用的, 比如 checkstyle.vim 可以检验你的编程风格, jad.vim 可以直接
    反编译 .class 文件等等.\r\n12. 常用配置
    在~/.vimrc 配置文件中你常常需要一些个性化配置. 比如上面写的一些宏定义, 一些
autocmd 定义等等. 比如:\r\n    set suffixes=.bak,~,.o,.h,.info,.swp,.aux,.bbl,.blg,.dvi,.lof,.log,.lot,.ps,.toc
        这样在vim中打开文件时, 按 tab 键补齐文件名时它会忽略上述文件.\r\n    set nu          显示行号
    set ai          设置自动缩进
    map Y y$        让 Y 和 D 一样, 要不然 Y 的本意和 yy 一样.\r\n13. 其他
    还有许多有意思的命令, 记录在这里免得忘记.\r\n    .                                               重复上次编辑命令.
    :g/^/exec \"s/^/\".strpart(line(\".\").\" \", 0, 4)   在行首插入行号
    :runtime! syntax/2html.vim                      转换 txt 成 html, 会按照你的
                                                    颜色配置来转\r\nVI高级命令集锦及VIM应用实例
作者：  转自：http://linux-down.kmip.net/  本文已被阅读：5 次
*****************************************************************************\r\n本文由正泰linux http://linux-down.kmip.net 搜集，整理，如需转载，请注明出处！
本站有大量的linux电子教程，软件，技术文档，欢迎大家访问！站长阿泰qq：253222170\r\n******************************************************************************\r\nVI高级命令集锦及VIM应用实例\r\njavalee 写到:\r\n1.交换两个字符位置
xp
2.上下两行调换
ddp
3.把文件内容反转
:g/^/m0/ (未通过)
4.上下两行合并
J
5.删除所有行
dG
6.从当前位置删除到行尾
d$
7.从当前位置复制到行尾
y$ 如果要粘贴到其他地方 p 就可以了\r\n由于vi 是建立在 EX 上的 所以 当键入 : 时就来到了 EX 命令状态
8.
:ab string strings
例如 \":ab usa United States of America\" ,
当你在文见里插入 usa 时
United States of America 就蹦出来了
9.
:map keys new_seq
定义你当前 键盘命令
10.
:set [all]
vi or ex 的编辑状态
如 显示每行 :set nu
11.
在命令状态下，nyy表示拷贝从光标行起的下n行内容，p表示paste,可刚复制的内容粘贴在光标处的
下面。\r\n12.
单个字符替换用r，覆盖多个字符用R，用多个字符替换一个字符用s，整行替换用S\r\n13.\r\n:%s/old_word/new_word/g
这个指令是于在整个文件中替换特定字符串\r\n14.光标控制\r\nk:上移 nk 上移n行
j:下移 nj 下移n行\r\n将光标移到第n行，按下 mk
将光标移到第m行，按下 \"ay\'k
即将第n到m的行存到a寄存器，以此类推，b，c........寄存器等\r\n这样就可以将你常用的需要复用的内容粘贴到不同的寄存器中以备用\r\n想粘贴到某处，直接将光标移到某地，按下 \'ap 即可,以此类推，b，c........寄存器等\r\n在当前屏幕中
H 跳到第一行
M 跳到中间一行
L 跳到最后一行\r\n15.
表8-2 删除命令
删除命令操作
d l 删除当前字符（与x命令功能相同）
d 0 删除到某一行的开始位置
d ^ 删除到某一行的第一个字符位置（不包括空格或TA B字符）
d w 删除到某个单词的结尾位置
d 3 w 删除到第三个单词的结尾位置
d b 删除到某个单词的开始位置
d W 删除到某个以空格作为分隔符的单词的结尾位置
d B 删除到某个以空格作为分隔符的单词的开始位置
d 7 B 删除到前面7个以空格作为分隔符的单词的开始位置
d） 删除到某个语句的结尾位置
d 4） 删除到第四个语句的结尾位置
d（ 删除到某个语句的开始位置
d } 删除到某个段落的结尾位置
d { 删除到某个段落的开始位置
d 7 { 删除到当前段落起始位置之前的第7个段落位置
d d 删除当前行
d /t e x t 删除从文本中出现\" t e x t\"中所指定字样的位置，一直向前直到下一个该字样所出现的
位置（但不包括该字样）之间的内容
d fc 删除从文本中出现字符\"c\"的位置，一直向前直到下一个该字符所出现的位置（包括
该字符）之间的内容
d tc 删除当前行直到下一个字符\" c\"所出现位置之间的内容
D 删除到某一行的结尾
d $ 删除到某一行的结尾
5 d d 删除从当前行所开始的5行内容
d L 删除直到屏幕上最后一行的内容
d H 删除直到屏幕上第一行的内容
d G 删除直到工作缓存区结尾的内容
d 1 G 删除直到工作缓存区开始的内容\r\n修改命令操作
c l 更改当前字符
c w 修改到某个单词的结尾位置
c 3 w 修改到第三个单词的结尾位置
c b 修改到某个单词的开始位置
c W 修改到某个以空格作为分隔符的单词的结尾位置
c B 修改到某个以空格作为分隔符的单词的开始位置
c 7 B 修改到前面7个以空格作为分隔符的单词的开始位置
c 0 修改到某行的结尾位置
c） 修改到某个语句的结尾位置
c 4） 修改到第四个语句的结尾位置
c（ 修改到某个语句的开始位置
c } 修改到某个段落的结尾位置
c { 修改到某个段落的开始位置
c 7 { 修改到当前段落起始位置之前的第7个段落位置
c tc 修改当前行直到下一个字符c所出现位置之间的内容
C 修改到某一行的结尾
c c 修改当前行
5 c c 修改从当前行所开始的5行内容\r\n.重复上一次修改！\r\n表8-4 替换命令
替换命令操作
G的开头处
    \"         移至当前行上一次所在位置（在光标移动之后）DD一个双引号
    \'\'        移至当前行上第一次所在位置的行的开头处(在光标移动之后)DD两个单引号\r\n19.
同时vi多个文件时，CTRL-SHIFT-6回到上一个文件，在本次vi的文件和上次vi的文件之间切换。
但是我发现一个BUG：在用CTRL-SHIFT-6切换到上一个文件后，用:args查看多文件vi状态时，
屏幕底部仍然显示目前vi的是刚才的文件。
(在HP-UX,Solaris,AIX上通过)\r\n也可以使用:
:e#
进行切换\r\n20.
sco 下VI 要在文本前同样的字符加用
%s/^/要加的内容/g 要在文本后同样的字符加
%s/$/要加的内容/g\r\n21.
如何去掉文本中的 ^M 硬回车？不必用binary传回去再ascii传回来的方式，用shell或者unix语句实现。\r\ncat filename |tr -d \'\\015\' >newfile
不同的unix系统还存在一些其他不同的命令,如:doscp
sed 也可以实现这个功能.\r\ndos2unix filename filename2
反之
unix2dos filename filename2\r\n在vi 中用:$s/^M//g
^是crtl-V crtl-M\r\n22.如何在\"unix命令行\"下将一个文件的某字符串用另一个串换掉\r\nsed \'s/string1/string2/gp\' file1 > file2\r\n23.将/etc/hosts下所有的地址都ping 2次\r\n1 #/usr/bin/sh
2 #grad /etc/hosts and ping each address
3 cat /etc/hosts|grep -v \'^#\' | while read LINE
4 do
5 ADDR=`awk \'{print $1}\'`
6 for MACHINE in $ADDR
7 do
8 ping $MACHINE -n 2
9 done
10 done\r\n24\r\n到前一个函数[[ ，到下一个函数]] ，括号配对% ，交叉参考Ctrl_] (事先用ctags做索引），回来用e# ` 编辑一个函数：vi -t 函数名 ,编辑加密文本vi -X\r\n25
在插入模式下ctrl+p，自动补齐剩余单词，以赖规则：tags，以有的单词等等\r\n*****************************************************************************\r\n本文由正泰linux http://linux-down.kmip.net 搜集，整理，如需转载，请注明出处！
本站有大量的linux电子教程，软件，技术文档，欢迎大家访问！站长阿泰qq：253222170\r\n******************************************************************************\r\n当今世界，文本编辑器种类繁多，大有\"乱花渐欲迷人眼\"之势。中国有句古语：手巧不如家什妙，作为IT业的专业人士，选择一款优秀的编辑软件至关重要。笔者认为：LINUX下的VIM※以其强大的功能和无穷的魅力将使您终生受益。\r\n作者:闫石 (iloveibm@163.com)
来自:http://www-900.ibm.com/developerWorks/cn/linux/l-tip-prompt/tip15/index.shtml\r\n由于被广泛移植，无论是PC机的DOS和WINDOWS，还是RISC/6000的AIX，乃至于IBM的大型机S/390，都能见到VIM的身影。然而，对于初学者，VIM的用户界面与使用方法非常不符合常规，甚至认为它比较混乱，无所适从。事实上，VIM编辑器是专门为经验丰富的用户设计的，它的界面和使用方法提供了更快的速度和更强的功能。对于熟知它的用户，VIM的许多特性节省了时间和击键次数，并可以完成一些其他编辑器无法完成的功能。\r\n学习的最好方法是实践，唯有如此，才能真正掌握其中的精髓。文中列举的实例，都是笔者在实际工作中遇到的，具有一定的代表性，请大家在阅读的过程中仔细体会。\r\n好了，现在让我们共同畅游神奇的VIM的世界！\r\n例一、两个常用的指令序列\r\nxp 左右交换光标处两字符的位置。
ddp 上下交换光标处两行的位置。\r\n例二、重复输入同一字符\r\n有时，我们可能想多次输入同一字符，VIM的插入功能可以很好的完成这项工作\r\n命令 80i=^ESC 一次可以输入80个字符= ,当然，80a=^ESC 也可以完成上述功能。\r\n请注意：此处的^ESC表示键盘左上方上的ESC键。\r\n例三、将两个文本数据文件按行逐条合并，并给出标尺\r\n数据文件1内容如下：
1-----
2-----
3-----\r\n数据文件2内容如下：
1=====
2=====
3=====\r\n要求的结果如下：
|--------1---------2---------3---------4---------5
1-----
1=====
|--------1---------2---------3---------4---------5
2-----
2=====
|--------1---------2---------3---------4---------5
3-----
3=====\r\n也许您会说，这还不简单，无非是反复拷贝、粘贴，任何一款文本编辑器都能完成上述功能。可是，如果这两个文件都很大，每个文件都成千上万行，恐怕简单的拷贝、粘贴就难以胜任了。因此，我们所关心的，是找到一种行之有效的方法，把枯燥乏味的工作留给计算机，我们只需发布指令。为达到此目的，请按以下步骤执行：\r\n㈠、将两文件合并，结果如下
1-----
2-----
3-----
1=====
2=====
3=====\r\n㈡、在两文件头尾相接的地方插入标志行，用以区分两个文件，本文采用的是一整行！字符
1-----
2-----
3-----
!!!!!!!!!!!!!!!!!!!!!!!!
1=====
2=====
3=====\r\n㈢、在标志行的下方输入标尺
1-----
2-----
3-----
!!!!!!!!!!!!!!!!!!!!!!!!
|--------1---------2---------3---------4---------5
1=====
2=====
3=====\r\n㈣、执行宏命令脚本merge_2r.vim，即在VIM编辑器中按如下键 :so merge_2r.vim 回车\r\n㈤、按下键盘上的=键，执行的结果如下
|--------1---------2---------3---------4---------5
1-----
1=====
|--------1---------2---------3---------4---------5
2-----
2=====
|--------1---------2---------3---------4---------5
3-----
3=====
|--------1---------2---------3---------4---------5
!!!!!!!!!!!!!!!!!!!!!!!!
|--------1---------2---------3---------4---------5\r\n㈥、将最后三行删除，即可得到我们需要的结果
|--------1---------2---------3---------4---------5
1-----
1=====
|--------1---------2---------3---------4---------5
2-----
2=====
|--------1---------2---------3---------4---------5
3-----
3=====\r\n怎么样，简单吗？请大家自己实际尝试一下。下面，我来详细讲解宏命令脚本merge_2r.vim 。\r\n该脚本内容如下：\r\n\"--------------------------------------------------------------------
\"Macro Function : Merge File1 And File2,Have Ruler in every record
\" Date : 2001/12/01
\" Author : Yan Shi
\"--------------------------------------------------------------------
\"1-----
\"2----- } Sample File1
\"3-----
\"!!!!!!!!!!!!!!!!!!!!!!!! Flag Row
\"|--------1---------2---------3---------4---------5 Ruler
\"1=====
\"2===== } Sample File2
\"3=====
\"--------------------------------------------------------------------
:1
:map = ma/!!!!!^M+:.co \'a-1^M/!!!!!^M2+:.m\'a^M+=\r\n前14行每行都以\"开始，表明该行是注释行，实际并不执行，只是方便读者阅读，只有最后两行才是真正的代码行。请注意：本例中的^M表示键盘上的回车键，并非^和M两个字符。为了讲述清楚，我把命令行分解开，逐一说明。\r\n首先将第一行置为当前行，然后执行map命令，将一大串VIM指令映像给字符=。这一大串VIM指令共分9步执行：\r\nma 将数据文件一的第一行标记为a
1-----
2-----
3-----
!!!!!!!!!!!!!!!!!!!!!!!!
|--------1---------2---------3---------4---------5
1=====
2=====
3=====\r\n/!!!!!^M 找到标志行,置为当前行
1-----
2-----
3-----
!!!!!!!!!!!!!!!!!!!!!!!!
|--------1---------2---------3---------4---------5
1=====
2=====
3=====\r\n+ 光标下移一行,即把标尺行置为当前行
1-----
2-----
3-----
!!!!!!!!!!!!!!!!!!!!!!!!
|--------1---------2---------3---------4---------5
1=====
2=====
3=====\r\n:.co \'a-1^M 把标尺行复制到标记行(数据文件一的第一行)的上方
|--------1---------2---------3---------4---------5
1-----
2-----
3-----
!!!!!!!!!!!!!!!!!!!!!!!!
|--------1---------2---------3---------4---------5
1=====
2=====
3=====\r\n/!!!!!^M 再次找到标志行,置为当前行
|--------1---------2---------3---------4---------5
1-----
2-----
3-----
!!!!!!!!!!!!!!!!!!!!!!!!
|--------1---------2---------3---------4---------5
1=====
2=====
3=====\r\n2+ 光标下移2行，即数据文件二的第一行置为当前行
|--------1---------2---------3---------4---------5
1-----
2-----
3-----
!!!!!!!!!!!!!!!!!!!!!!!!
|--------1---------2---------3---------4---------5
1=====
2=====
3=====\r\n:.m\'a^M 把数据文件二的第一行移至标记行的下方
|--------1---------2---------3---------4---------5
1-----
1=====
2-----
3-----
!!!!!!!!!!!!!!!!!!!!!!!!
|--------1---------2---------3---------4---------5
2=====
3=====\r\n+ 光标下移一行，即数据文件一的第二行置为当前行
|--------1---------2---------3---------4---------5
1-----
1=====
2-----
3-----
!!!!!!!!!!!!!!!!!!!!!!!!
|--------1---------2---------3---------4---------5
2=====
3=====\r\n= 这一步很关键，是典型的递归调用，重复完成以上步骤\r\n例四、在文件中置入行号\r\n工作中，我们有时希望把行号置入文件中，而VIM提供的功能 :set nu 只能显示行号，不能编辑或将其置入文件当中，下面的宏命令脚本row_num.vim可以完成此项功能。\r\n\"------------------------------------------
\"Macro Function : Source File Add Row_Num
\" Date : 2001/12/01
\" Author : Yan Shi
\"------------------------------------------
:%s/^/^I/
:$
:let end=line(\".\")
:1
\"------------------------------------------
:let num=1
:while num<=end
:let line=getline(\".\")
:let temp=substitute(line,$,num,\"\")
:call setline(\".\",temp)
:+
:let num=num+1
:endwhile
\"------------------------------------------\r\n请注意：本例中的^I表示键盘上的TAB键，并非^和I两个字符。下面，我针对该宏命令脚本逐一讲解。\r\n:%s/^/^I/ 每一行的行首添加一个TAB字符
:$ 到文件的末行
:let end=line(\".\") 末行的行号 ==〉变量 END，函数line的功能是取得指定行的行号，此处参数\".\"表示当前行
:1 到文件的首行
\"------------------------------------------
:let num=1 1 ==〉计数器
:while num<=end
:let line=getline(\".\") 取当前行的内容 ==〉变量 LINE
:let line=substitute(line,$,num,\"\") 在变量 LINE 的前面置入行号
:call setline(\".\",line) 将变量 LINE 的内容写回当前行
:+ 下移一行
:let num=num+1 计数器加一
:endwhile 循环执行，直到文件结束
\"------------------------------------------\r\n有关正则表达式的使用\r\nUNIX/LINUX下的很多工具之所以强大、灵活，关键是因为有了正则文法和元字符，这也是VIM乃至UNIX/LINUX系统的精华所在。正因为使用灵活，因此掌握起来比较吃力，如果不是真正理解，实际运用中会出现千奇百怪的错误。因此，有必要对这部分知识多花些气力。下面结合具体实例讲解。\r\n例五、有一文件，包含某外企的中国员工的资料，首先是姓名，然后是两个空格,其次是15位身份证号码。\r\nzhang.fei 430759701022003
diao.chan 651302801225012
guan.yu 342869680413001
xi.shi 120638780214006
liu.bei 210324650708001\r\n现在，有以下问题需要解决：\r\n按照外国人的习惯，应该是名在前，姓在后。因此，文件中的姓名字段需要修改。
姓与名的首字母应该大写。
根据身份证号码，还可以判断出生年月日，将其作为一个新字段添加。
根据身份证号码，可以判断出性别。若为男性，添加male，若为女性，添加female 。
将男女员工分开，男员工在前，女员工在后。
将各字段数据左对齐\r\n最终结果如下：\r\nFei.Zhang 430759701022003 1970/10/22 male
Yu.Guan 342869680413001 1968/04/13 male
Bei.Liu 210324650708001 1965/07/08 male
-----------------------------------------------
Chan.Diao 651302801225012 1980/12/25 female
Shi.Xi 120638780214006 1978/02/14 female\r\n为了完成上述功能，只需执行脚本employee.vim ，使用方法为 :so employee.vim 回车即可。\r\n脚本内容如下：\r\n:%s/ / /
:%s/\\(............\\)\\( *\\)/\\1/
:%s/\\([A-Za-z][A-Za-z]*\\)\\(\\.\\)\\([A-Za-z][A-Za-z]*\\)/\\u\\3\\2\\u\\1/
:%s/$/ xxxxxx/
:%s/\\([0-9]\\{6}\\)\\([0-9]\\{6}\\)\\([0-9]\\{3}\\) \\(xxxxxx\\)/\\1\\2\\3 \\2/
:%s/\\(..\\)\\(..\\)\\(..\\)$/19\\1\\/\\2\\/\\3
:%s/$/ xxxxxx/
:%s/\\([0-9]\\{14}[13579]\\)\\(.*\\)\\(xxxxxx\\)/\\1\\2male /
:%s/\\([0-9]\\{14}[02468]\\)\\(.*\\)\\(xxxxxx\\)/\\1\\2female/
:$
:s/.*/&^M-----------------------------------------------
:g/female/.m$\r\n在这个脚本中,使用了大量的正则表达式，这里仅对涉及到的正则表达式做一简要介绍。有关正则表达式的内容相当多，本文不可能占用大量篇幅叙述，请大家谅解。\r\n% 地址范围符号，代表文件中的所有行,作用等同于地址范围 1,$
. 与任意单字符(换行符除外)匹配，例如 y.s 可以匹配 yas y.s 或 y s 等等。
* 与前一字符的0次或多次出现匹配，例如 y*s 可以匹配 yys yyyyys 或 s 等等。
$ 与行尾匹配。
& 代表模式匹配中出现的字符串，例如 s/abc/&def 是把当前行的abc替换成abcdef 。
[] 匹配[]中出现的字符，例如[abc]匹配字符 a，b 或 c ，[a-zA-Z]匹配所有的英文字符。
\\( \\) \\(和\\)之间出现的内容可以由\\num来替代。
\\1\\2\\3 替代\\(和\\)之间出现的内容。
\\u 将后续字符串的首字母大写。
\\{num} 与前一字符的num次出现匹配。\r\n现在，我们对脚本逐条讲解，希望能帮助大家理解正则文法。\r\n⑴:%s/ / /
将文件中每行出现的2个空格替换为10个空格。\r\nzhang.fei 430759701022003
diao.chan 651302801225012
guan.yu 342869680413001
xi.shi 120638780214006
liu.bei 210324650708001\r\n⑵:%s/\\(............\\)\\( *\\)/\\1/
保留行首的12个字符，将其余的空格删除，这样，前两个字段就对齐了。\r\nzhang.fei 430759701022003
diao.chan 651302801225012
guan.yu 342869680413001
xi.shi 120638780214006
liu.bei 210324650708001\r\n⑶:%s/\\([A-Za-z][A-Za-z]*\\)\\(\\.\\)\\([A-Za-z][A-Za-z]*\\)/\\u\\3\\2\\u\\1/
将文件中每行出现的雇员姓名互换，并将首字母大写。\r\nFei.Zhang 430759701022003
Chan.Diao 651302801225012
Yu.Guan 342869680413001
Shi.Xi 120638780214006
Bei.Liu 210324650708001\r\n⑷:%s/$/ xxxxxx/
在每一行的行尾添加2个空格和6个x\r\nFei.Zhang 430759701022003 xxxxxx
Chan.Diao 651302801225012 xxxxxx
Yu.Guan 342869680413001 xxxxxx
Shi.Xi 120638780214006 xxxxxx
Bei.Liu 210324650708001 xxxxxx\r\n⑸:%s/\\([0-9]\\{6}\\)\\([0-9]\\{6}\\)\\([0-9]\\{3}\\) \\(xxxxxx\\)/\\1\\2\\3 \\2/
将xxxxxx替换成出生年月日。\r\nFei.Zhang 430759701022003 701022
Chan.Diao 651302801225012 801225
Yu.Guan 342869680413001 680413
Shi.Xi 120638780214006 780214
Bei.Liu 210324650708001 650708\r\n⑹:%s/\\(..\\)\\(..\\)\\(..\\)$/19\\1\\/\\2\\/\\3
将年月日用/字符分隔，并在年前添加19。\r\nFei.Zhang 430759701022003 1970/10/22
Chan.Diao 651302801225012 1980/12/25
Yu.Guan 342869680413001 1968/04/13
Shi.Xi 120638780214006 1978/02/14
Bei.Liu 210324650708001 1965/07/08\r\n⑺:%s/$/ xxxxxx/
在每一行的行尾添加2个空格和6个x\r\nFei.Zhang 430759701022003 1970/10/22 xxxxxx
Chan.Diao 651302801225012 1980/12/25 xxxxxx
Yu.Guan 342869680413001 1968/04/13 xxxxxx
Shi.Xi 120638780214006 1978/02/14 xxxxxx
Bei.Liu 210324650708001 1965/07/08 xxxxxx\r\n⑻:%s/\\([0-9]\\{14}[13579]\\)\\(.*\\)\\(xxxxxx\\)/\\1\\2male /
身份证号码末位是奇数的，将xxxxxx替换成male\r\nFei.Zhang 430759701022003 1970/10/22 male
Chan.Diao 651302801225012 1980/12/25 xxxxxx
Yu.Guan 342869680413001 1968/04/13 male
Shi.Xi 120638780214006 1978/02/14 xxxxxx
Bei.Liu 210324650708001 1965/07/08 male\r\n⑼:%s/\\([0-9]\\{14}[02468]\\)\\(.*\\)\\(xxxxxx\\)/\\1\\2female/
身份证号码末位是偶数的，将xxxxxx替换成female\r\nFei.Zhang 430759701022003 1970/10/22 male
Chan.Diao 651302801225012 1980/12/25 female
Yu.Guan 342869680413001 1968/04/13 male
Shi.Xi 120638780214006 1978/02/14 female
Bei.Liu 210324650708001 1965/07/08 male\r\n⑽:$ 到文件的最后一行\r\n⑾:s/.*/&^M-----------------------------------------------
在文件的最末行插入一行 \"-\" 字符。\r\nFei.Zhang 430759701022003 1970/10/22 male
Chan.Diao 651302801225012 1980/12/25 female


:g/female/.m$
将所有的女员工记录移至文件尾。
\r\n<P>Fei.Zhang 430759701022003 1970/10/22 male
Yu.Guan 342869680413001 1968/04/13 male
Bei.Liu 210324650708001 1965/07/08 male
-----------------------------------------------
Chan.Diao 651302801225012 1980/12/25 female
Shi.Xi 120638780214006 1978/02/14 female
\r\n<P>笔者目前正在为某外资公司从事大型机（IBM S/390）的软件开发，一切工作都在TSO环境中进行。为了对编写的程序进行测试，必须准备测试数据。有过大型机开发经验的人会知道，通过TSO，输入字符型数据还可以，如果要输入16进制数据，操作起来很麻烦。因为16进制数是纵向排列的，输入时既不方便，又很容易错位。怎么解决呢？我尝试了几种办法，实际证明，用VIM最方便。
\r\n<P>例六、下列数据 1234567890ABCDEF ，将其变成 13579ACE 24680BDF 的形式，这样，数据就可以很方便的粘贴到TSO环境中了。
\r\n<P>下面给出宏命令脚本change_d.vim
\r\n<P>\"----------------------------------------------------
\"Macro Function : Convert Char Arrange Direction
\"
\" Sample : 40 50 60 ==&gt; 4 5 6
\" 0 0 0
\" Date : 2001/12/01
\" Author : Yan Shi
\"----------------------------------------------------
:s/.*/&amp;^M/
:1
:map = malx+$p-`al=
\r\n<P>说明如下:
\r\n<P>⑴ :s/.*/&amp;^M/ 在数据行下方添加一空行。
⑵ :1 回到文件的首行的首字符。
⑶ :map = malx+$p-`al= 将一大串VIM命令映像给字符=
\r\n<P>① ma 将首字符标记为a
② l 光标右移一个字符
③ x 删除光标处字符
④ + 移至下一行
⑤ $ 到行尾
⑥ p 将删除的字符粘贴
⑦ - 回至上一行
⑧ `a 返回到标记字符处
⑨ l 光标右移一个字符
⑩ = 递归调用,重复以上步骤，直到将该行所有的数据处理完。
\r\n<P>上面的这几个实例，展示了VIM强大的文本处理功能，但这远不能覆盖其全貌。VIM的命令很多，而且使用灵活，需要狠下一番气力才能熟练掌握。笔者年龄尚小，经验还很欠缺，希望本文能够起到抛砖引玉的作用。由于时间的原因，上述实例仅在DOS和WINDOWS环境下测试，没有在其他系统下进行进一步的测试，希望各位同行、前辈不吝赐教，谢谢！
\r\n<P>※ VIM 意为 VI Improved ，与VI99%向下兼容。而且，VIM提供了许多VI不具备的功能，内置了诸多函数，因此，建议有经验的VI用户对VIM有所了解，您会发现，转向VIM 是明智之举。欲查询有关VIM的资料，请参考 <A href=\"http://www.vim.org/\"><FONT color=#0000ff>http://www.vim.org</FONT></A>
\r\n<P>注：本文使用 VIM 6.0 版本
\r\n<P>作者简介
闫石，工程师。您可以通过电子邮件：<A href=\"mailto:iloveibm@163.com\"><FONT color=#0000ff>iloveibm@163.com</FONT></A> 或者 <A href=\"mailto:yan-shi@sino-com.com\"><FONT color=#0000ff>yan-shi@sino-com.com</FONT></A> 和他联系。
\r\n<P>附录A:一个用vi作表单的在线教程
<A href=\"http://www-900.ibm.com/developerWorks/cn/cnedu.nsf/linux-onlinecourse-bytitle/9F896668D7EB5CA948256A710030E157?OpenDocument\"><FONT color=#0000ff>http://www-900.ibm.com/developerWorks/cn/cnedu.nsf/linux-onlinecourse-bytitle/9F896668D7EB5CA948256A710030E157?OpenDocument</FONT></A>
\r\n<P>附录B:vi 命令常见问题解答
<A href=\"http://www.linuxsir.com/bbs/showthread.php?s=&amp;threadid=23957\"><FONT color=#0000ff>http://www.linuxsir.com/bbs/showthread.php?s=&amp;threadid=23957</FONT></A>
附录C:命令行下在线教程:
运行vimtutor即可学习!
\r\n<P>vi 命令常见问题解答
\r\n<P>作者：译者Elale
\r\n<P>[vi-faq中文版]
\r\n<P>0.0 - 引言 -- 我怎样用这个FAQ
\r\n<P>这个文档分为了几个部分.首先,第0节和第1节介绍了什么是vi;第2节则收录了很多新
学者的问题,一些对vi没有很多经验的人也经常问这些问题.这里面包括诸如“命令模式
和插入模式之间的区别”,以及“我怎样拷贝和粘贴”之类的问题.第3节是面向vi的中级
用户的,它从问题“我如何查找和替换”开始,逐步深入,直到对vi里面的宏（Macro）的
用法讨论为止.第3节还包括了一个vi的快速参考,有一个规范的vi命令列表.再下面,
是一个有关“:set”命令的列表,包含了所有能定vi环境的变量,这些变量也可以在
.exrc文件中定义.
\r\n<P>我们已经在一个运行SunOS和UCB版本vi的机器上验证了快速参考.除了SunOS带的vi外,
每个命令都可以在系统V和UCB版本vi运行,但是我个人并没有验证这一点.
\r\n<P>除非我们在文档中指明,缺省我们假定你处在命令模式下.
\r\n<P>我们还尝试保留尽可能多的术语,因为在原始的vi文档中使用了这些术语,尽管我可能
忘了它的本来含义.
\r\n<P>0.1 - 索引
\r\n<P>第一个文件：
\r\n<P>0.0 - 引言 -- 我怎样用这个FAQ？
0.1 - 索引
0.2 - 我可以散发这个FAQ吗？
0.3 - 你能为这个FAQ做什么？
\r\n<P>1.0 - 什么是vi?
1.1 - 关于vi有什么重大的交易? 为什么大家都用它? 更进一步说,为什么我要用它?
1.2 - 噢! 这听起来不错! 有没有理由不用vi?
1.3 - vi能在多少不同的操作系统下面运行?
1.4 - 好吧, 你说服了我. 我决定开始使用vi. 我该从哪儿开始?
1.5 - vi有其他一些可用的变种吗?
\r\n<P>2.0 - vi入门
2.1 - 有什么游戏帮助我们学习vi吗?
2.2 - 命令模式和插入模式有什么区别?
2.3 - 等等,我的键盘没有&lt;Esc&gt;键,我该怎么办?
2.4 - 那些~s是什么东西?
2.5 - 我无法习惯用 hjkl, 你有什么建议吗?
2.6 - 我如何才能不存盘就退出?
2.7 - 我怎样插入一个文件?
2.8 - 我怎样查找文本?
2.9 - 我怎样搜索一个控制序列?
2.10 - 我怎样重新格式化文本?
2.11 - 我怎样复制文本?
2.12 - 啊! 我刚才敲了一个dG,然后我的论文就没有了! 我该怎么办?
 (或者,我刚才犯了个错误,我该怎么办?)
2.13 - 我正在写我的论文,被告知我必须将每一节都放在不同的文件,我该怎么办?
2.14 - 所有的:命令都是怎样处理的?
\r\n<P>3.0 - 怎样查找和替换?
3.1 - 我怎样在vi中运行一个程序?
3.2 - 啊! 我正在写我的论文, 系统崩溃了! 怎么办?
3.3 - 有没有使vi对程序员更友好的窍门?
3.4 - 宏 -- 我怎样写宏?
3.5 - 我怎样将一个功能键定义成一个宏?
3.6 - 有没有办法缩写文本?
3.7 - 我怎样在当前文档中做拼写检查?
3.8 - 我手头有一个硬拷贝的终端, 我还能用vi吗?
3.9 - 好了,是不是处在开放模式下的原因呀?! 但是我现在没有用硬拷贝终端,
 它还是在开放模式呀?
\r\n<P>第二个文件:
\r\n<P>4.0 - vi档案的在线帮助在哪?
5.0 - 好玩的vi诀窍,无聊的宏
5.1 - 好玩的vi诀窍
5.2 - 好玩的宏
6.0 - 依字母顺序的vi快速参考
6.1 - 命令模式的输入选项(:命令)
6.2 - 设置选项(set)
7.0 - 建立 .exrc文件
7.1 - .exrc文件的样本
8.0 - vi的漏洞
9.0 - 术语表
10.0 - 关于vi的参考书目
\r\n<P>0.2 - 我可以散发这个FAQ吗？
\r\n<P>可以!只要你没有对它做任何修改,或者用它来赚钱.
\r\n<P>0.3 - 你能为这个FAQ做什么？
首先, 把你发现的错误告诉我. 如果你有什么建议我们也很欢迎. 你认为还不清楚的
地方告诉我们,我们同样欢迎. 还有, 使用vi! (Spread the word) 我很抱歉我无法将
所有对这FAQ有贡献的人都列出来, 因为许许多多的人都给过我建议和帮助,如果我将
他们都列出来的话,那么恐怕这张贡献者的清单将和这个文档本身一样长了.
\r\n<P>1.0 - 什么是vi?
vi是个可视化的编辑器(vi就意味着可视化--VIsual). 那么,什么是可视化的编辑器呢？
(相对于非可视化的编辑器来说）?可视化的编辑器就是可以让你在编辑文本的时候看到
它们.今天,这听起来似乎非常普通,反之,非可视化的编辑器似乎很奇怪. 非可视化的
编辑器的例子可以举出不少:如ed, sed和edlin(直到相当近的一段时间内,它是DOS自带
的最后一个编辑器) 等.vi是威廉.侨伊写的,作为BSD UNIX的一部分. 后来AT&amp;T也开始
用vi, 于是标准UNIX也开始用vi了.
\r\n<P>1.1 - 关于vi有什么重大的交易吗? 为什么大家都用它? 更进一步说,为什么我要用?
vi是UNIX下面的缺省编辑器, 因此几乎近来所有的UNIX都捆绑了vi(近来是指1984年左右).
这意味着无论何时你跨平台使用某种UNIX,你都知道在你指尖下面有一个强力的编辑器.
为什么不是别的呢? vi是个强大的编辑器.同样,一旦你了解了vi,你就能很快的编辑你的
文件,因为它非常能节省你的敲键次数. 由于它在插入和命令两种情况下使用不同的模式,
它比大多数的不基于这种模式的编辑器要快. 而且,vi非常小(我机器上面的版本只有
200K).还有,vi几乎能做任何事,只要你知道如何使它做你想做的事.
\r\n<P>1.2 - 噢! 这听起来不错! 有没有理由不用vi?
有. 有一个非常好的理: vi稍微有些难学, 如果你开始学的话,vi又慢又让人痛苦,
当然,一旦你学会了, vi就快多了. 但是学习的过程很慢. 有人曾经问我, 如果vi是个
比较易学的编辑器, 它是否直观(intuitive)呢? 我一般这样回答:\"是的,我们有些人是
这样认为.但是大多数人认为我们疯了.\"
\r\n<P>1.3 - vi能在多少不同的操作系统下面运行?
UNIX. 就是它. 尽管如此,还是有很多vi的变种运行在不同的操作系统上. 我就在以下
一些操作系统上用过vi: UNIX, DOS, OS/2, MAC SYSTEM 7.(后面有一个有关细节的列表)
\r\n<P>1.4 - 好吧, 你说服了我. 我决定开始使用vi. 我该从哪儿开始?
好吧, 狡猾的家伙. 关于vi有很多很好的书:大多数讲UNIX的书至少有一章给了vi,而且
有不少是专门讲vi的书.我没有什么偏爱. 所以你最好是问问你们那儿的vi高手们他们
是从哪儿学来的. 还有,到处试. 用vi打开一个不重要的文档(你的论文不象是个学vi的
好实验品),然后再到处. 我无法想象有人学习vi却不花相当多的时间去到处试试. 记住:
如果你有些地方不明白了, 只要敲两次&lt;Esc&gt;键,你就又回到命令模式下了. 我要提到的
一点是,我想在这里提比较合适,就是如果要成为系统管理员或者其他对UNIX配置
做什么修改的话,最好是学学ed或者ex,因为有些版本的UNIX没有把vi放在根分区里面,
这样你就可能无计可施了. ed是个不错的选择.
\r\n<P>1.5 - vi有其他一些可用的变种吗?
只能列出一部分:STvi (STevie), elvis, vile, vim, 和nvi, xvi.
elvis适用于:Amiga, DOS, OS/2, Unix, VMS, Atari.
STevie适用于: Atari ST, DOS, Unix, Mac System 7.
Mac System 7可以在很多info-mac的镜象站点获取,在/info-mac/text下.
(例如<A href=\"ftp://ftp.hawaii.edu/\"><FONT color=#0000ff>ftp.hawaii.edu</FONT></A>)
nvi是将和BSD 4.4捆绑在一起的vi.
vim适用于: Amiga, DOS, Mac System 7, Unix.
Amiga, DOS,和源码可以在以下站点换取:ftp.fu-berlin.de /misc/editors/vim
Mac System 7可以在很多info-mac的镜象站点获取,在/info-mac/text下.
(例如<A href=\"ftp://ftp.hawaii.edu/\"><FONT color=#0000ff>ftp.hawaii.edu</FONT></A>)
vile适用于: DOS, OS/2, Unix, VMS.
xvi适用于: DOS, Unix.
vi的变种之间很有很多差异.很多都改进了vi,大多数都可以使用在这个文档
种列出的命令,但是有一些不同的地方.更进一步的细节,你可以参考这些变
附带的相应的文档.
\r\n<P>2.0 - vi入门
对vi的初学者来说,有些基本的提示.第一,任何时候,手头都要有一份命令摘要.
我们将在后面给出一个快速参考/命令摘要. 第二, 找一本vi方面的比较好的书.
这个文档不是学vi的最佳途径(最起码现在还不是),我不敢保证这个文档能教会一个
对vi一无所知的人, 而很多书已经做到了这一点. 但是,我们这里还是给出了不少
提示. 对选择书籍来说,有一个标准的原则:买之前一定要仔细阅读. 要了解这本书
对你是否有意义.确信它能在你练习vi的时候有用. 和其他的书做个比较 -- 不管怎样,
vi可能让你感到非常莫名其妙, 而且你要确信这么一点:是书让你糊,而不是
你低估了学vi的难度.
还有, 找一些诸如\"学vi\"(vilearn),\"vi向导\"(vitutor)之类的软件来帮助你掌握
vi的基本知识.
\r\n<P>2.1 - 有什么游戏帮助我们学习vi吗?
这似乎很无聊, 但是事实上UNIX系统里面有不少游戏可以帮助你学习使用vi.这些帮助
主要是一些基本知识. 虽然我还不知道有哪个游戏可以帮你学习vi的所有命令, 但我
确实知道有一些可以帮助你学习使用 hjkl来移动光标. NetHack,一个类Rogue的游戏,
就对这非常有帮助. 而且它是一个很大的游戏,能玩很长一段时间. 我没有贬低其他游戏
的意思,这些游戏是: rogue, moria, omega, worm, snake.)
\r\n<P>2.2 - 命令模式和插入模式有什么区别?
vi将命令模式和插入模式区分开来,这经常被认为是vi的一个大问题,但往往这也被认为是
vi的优势所在. 理解其中的区别是掌握vi的关键.vi启动时,开始处于命令模式;在这种模式
下,我们可以在文件中到处移动,改变文本的某个特定区域, 剪切, 复制和粘贴文本,还有更
多. 插入模式是指用户可以真正插入文本.换句话说,命令模式是用来在文件中移动,而插入
模式是用来在文件中键入文本. 有些命令,例如: a, i, c, C, O, o和其他一些可以从命令
模式切换到插入模式. &lt;Esc&gt;键或者^C(CRTL+C)可以脱离插入模式而返回到命令模.
你要适应这种差别. 它使得vi区别于其他的编辑器. 它也使你能在你的手不离开标准
键盘做很多事情.
\r\n<P>2.3 - 等等,我的键盘没有&lt;Esc&gt;键,我该怎么办?
试试敲 ^[(CTRL+[). 如果你的键盘有一个&lt;Meta&gt;键,再试试它.如果还不行,再试试^3.
\r\n<P>2.4 - 那些~s是什么东西?
它们仅仅是用来让你知道你的文档末尾在哪儿.实际上它们并不在你的文档里面,所以
你用不着担心它们.
\r\n<P>2.5 - 我无法习惯用 hjkl, 你有什么建议吗?
首先,如果你的终端设置正确而且你连接的也没有问题的话,你可以使用箭头键.但是,
如果你认为你要经常使用vi,那么最好是习惯使用 hjkl,因为它们敲起来更. 而且,
有时候连接出问题了,使得ESC序列都可能丢失了.(这样你可能就无法使用箭头键了--译注)
\r\n<P>2.6 - 我如何才能不存盘就退出?
:q!可以做到这一点. 如果vi看起来冻住了,确信你没有错敲了个 ^S. 敲^Q可以解开^S.
\r\n<P>2.7 - 我怎样插入一个文件?
:r &lt;文件名&gt;
例如,要插入文件/etc/motd, 可以敲 :r /etc/motd.
这将把文件插入到光标处.如果你在r前面指定了一个数字,那么这条命令将把文件插入
到那个位置.
\r\n<P>2.8 - 我怎样查找文本?
/&lt;文本&gt;将向前查找, ?&lt;文本&gt;将向后查找. ??或者//将重复上次查找. 在UNIX下,这已经
是个可爱的标准用法了. 而且, 在vi中, n将查找文本下一次的出现位置. N重复上次查找,
不过逆转了查找的方向. 在查找中可以使用规范.
\r\n<P>2.9 - 我怎样搜索一个控制序列?
/^V^&lt;序列&gt;
^V会告诉vi照字面理解下一个字符,不要把它看作是一条命令.
\r\n<P>2.10 - 我怎样重新格式化文本?
如果你的计算机有一个名叫fmt的程序, 你要做的仅仅是在命令模式下面敲!}fmt(记住,
不要在前面加. 这可以重新格式化你的文件,从光标所在的位置一直到当前段落的结尾.
如果你的机器里面没有fmt这个程序, 你就得去找个类似的软件了(我记得在公共域里面
有不少这样的程序,但是我对此了解不多)
\r\n<P>2.11 - 我怎样复制文本?
这有点复杂.把这节拿出来,多看几遍;还有,一定要多做实验.
\"&lt;字母&gt;yy可以把一行文本拷贝到寄存器中(这里的寄存器是vi的术语,指可以存放剪切和
拷贝下来的东西的地方), &lt;字母&gt;里面的字母必须是a到z之间的一个. \"&lt;字母&gt;dd可以把
一行剪切下来放到寄存器里面. 你可以在yy或者dd前面用数字指明要拷贝或者剪切的
行数.如果&lt;字母&gt;中的字母是大写的话,意味着把文本插入到寄存器中已有的文本之前.
\"&lt;字母&gt;p把文本插入到光标之后,\"&lt;字母&gt;P把文本插入到光标之前.如果寄存器中含有某
一行的开头或结尾,这一行将会被放到另一合适的行. Y是yy的快捷方式. 还有, y$, yH,
yM,等等,都是可以用的.d命令也是一样的.如果要快速的剪切和粘贴, 你就无须指定寄存器
了.如果这样的话,你就不能往寄存器里面添加文本了.而且只要有一个删除命令的话,
寄存器中的东西就没有了(包括x命令). 举例来说,如果要移动上一段的话,你可以把光标
移到段落的开头,敲\"a13dd,再把光标移到你想要放文本的地方,敲\"ap,就可以把那段文本
放到光标所在的行后面. 现在,大概你想要剪切和粘贴文本到不是行末尾的区域去.我们
来看如何做到这一点:我们可以使用 m&lt;字母&gt; 命令来标记一个区域,这个字母可以和
剪切/粘贴寄存器的字母相,因为它们是保存在内存中的不同位置. 然后,
敲\"&lt;寄存器&gt;`&lt;字母&gt;[yy或者dd], 这里的寄存器就是要保存文本的那个寄存器,&lt;字母&gt;
是用来标记的,yy和dd是你的操作.
\r\n<P>2.12 - 啊! 我刚才敲了一个dG,然后我的论文就没有了! 我该怎么办?
(或者,我刚才犯了个错误,我该怎么办?)
u可以撤消你刚才的操作.U可以撤消你对当前行的修改(当然,一行对于一篇论文来说当然
很不够了). :e!可以不保存修改而重新把你的文件调进来. 还有,你删除的文本都保存在从
0到9编号的寄存器里.所以,\"&lt;n&gt;p就可以把上第n次的删除文本粘贴出来.你可以按如下的
方法迅速地查看所有删除的文. 先试一个,不对的话,敲u,再试下一个.(为加速这个过程,
这时vi中的.命令和通常的用法不一样了.它不是重复上次操作,而是试下一个寄存器,这样
你要做的无非就是: \"1p u . u .,直到你撤消了你想撤消的删除操作)
\r\n<P>2.13 - 我正在写我的论文,被告知我必须将每一节都放在不同的文件里,我该怎么办?
:[m],[n]w &lt;文件名&gt;可以将从第m行到第n行之间的文本保存到&lt;文件名&gt;所指定的文件中.
这种行序号方法几乎在所有的:命令下都可以使用. 如果你用命令:[m],[n] w &gt;&gt;&lt;文件名&gt;,
这些文本将添加到文件的后面.
\r\n<P>2.14 - 所有的:命令都是怎样处理的?
:后面的命令都是从ex编辑器里面过来的. 这就给vi加入了很多灵活性,也使vi功能更强
大. 例如, 有很多的方法可以用来查找和替换,它们有很多的类似地方(事实上,它们在
某种意义上说都是一样的)
\r\n<P>3.0 - 怎样查找和替换?
有很多方. 最简单的是:
:s/old/new/g, 但是,这仅对当前行起作用..., 所以,我们用
:%s/old/new/g, 更一般的,我们还可以用
:[范围]s/old/new/[cg],这里,[范围]是任意的行范围,包括行号,$(文件末尾),.(当前行),
%(当前文件),或者两个行号之间加个破折号(或者可以这样: .,+5,这表示下面5行).
[cgi]是c,g,i中间的一个或者什么也没有.c告诉vi每次替换的时候要给提示,g是说对
所有一行中出现的地方都做替换.i则是指在查找时不区分大小写.如果最后一个斜杠(/)
后面没有东西的话,那么vi只替换在行中第一次匹配的地方. 我比较喜欢这样做:
:g/foobar/s/bar/baz/g, 这个命令首先搜寻foobar,然后把它变成foobaz. 它没有改变
jailbars, 而其他的一些命令可能会改变jailbars. 这是我的方法,但是可能比较难记.
当然,你还可以在查找的的时候使用正规式,以及在替换文本的时候使用其他一些命令.如果
你在正规式里用\\(和\\)来剥离一个序列的话,你会发现你可以做很多好玩的事情. 例如:
:g/\\(foo\\)\\(bar\\)/s/\\2/\\1baz/g 将foobar替换成foobaz
还有一些特殊的序列:
&amp; 所有查找时匹配到的东西
\\[1-9] 1到9号用\\(和\\)括起来的东西
\\u 下一个字符将被变成大写.
\\U 以后的字符都变成大写,直到遇到\\e或\\E
\\l 下一个字符将被变成小.
\\L 以后的字符都变成大写,直到遇到\\e或\\E
\\[Ee] 更改大小写的选择区域的终点
\r\n<P>3.1 - 我怎样在vi中运行一个程序?
:!命令 可以在vi中运行程序. :sh会启动一个交互式的外壳(SHELL).在这个外壳
里面, 如果你愿意,你还可以再次运行vi. 当你在编辑Makefiles和配置文件来编译
某个程序的时候,这可能比较有用. 这比:e优越之处在于它无须保存文件,而且如果
你退出外壳的时候,vi还回到原来的地方.(当然,我还是建议你先保存一下文件)
\r\n<P>3.2 - 啊! 我正在写我的论文, 系统崩溃了! 怎么办?
不要怕! 你会收到一封电子邮件,里面就是你的论文.敲入vi -r &lt;文件名&gt;
(这个文件名就是系统崩溃时你正在编辑的文件)你就可以恢复出你的论文来.只敲
vi -r将把所有可能恢复的文件都列出来.
\r\n<P>3.3 - 有没有使vi对程序员更友好的窍门?
:set ai可以让vi自动对齐.
:set sw=#,#是移动的宽度(shiftwidth),或者说TAB键的宽度(tabwidth);你可以
用&lt;&lt;或者&gt;&gt;命令来左移或右移某一行. 还有, 你可以使用 &lt;%或&gt;%来将{,(或[等符号
括起来的文本都左移或右移;这时候,你必须把光标放在这些符号({,(或[)上面.
:set sm会在你敲},]或)显示出对应匹配的{,[或(来.
:set lisp会对lisp编程有些帮助. ()被移到s表达式(s-expressions)外面,如果
原子(atoms)没有停止则{}将被移走.
\r\n<P>3.4 - 宏 -- 我怎样写宏?
:map &lt;lhs&gt; &lt;rhs&gt;, 其中&lt;lhs&gt;最多10个字符,&lt;rhs&gt;最多100个字符. 以后,如果
你敲了&lt;lhs&gt;,vi就会用&lt;rhs&gt;来取代它.所有的宏都是在命令模式下开始的,但是可以
在你想在的模式下终止. 记住,在你想用的控制字符前面加上^V.
:unmap &lt;lhs&gt;将删除这个宏. :map！&lt;lhs&gt; &lt;rhs&gt; 使得&lt;lhs&gt;将&lt;rhs&gt;插入到文档
中去.
\r\n<P>3.5 - 我怎样将一个功能键定义成一个宏?
如果&lt;lhs&gt;是#n,n是0-9之间的一个数,那么这个宏就映射成某一个功能键了.(你
可以试一下F1-F10之间的键--译者)
\r\n<P>3.6 - 有没有办法缩写文本?
当然了. 这可是vi呀,它能做任何事情!
:ab email <A href=\"mailto:ellidz@midway.uchicago.edu\"><FONT color=#0000ff>ellidz@midway.uchicago.edu</FONT></A> 可以在你敲完email后,把那个没有缩写
的文本插入到文件中. :una email取消缩写.
\r\n<P>3.7 - 我怎样在当前文档中做拼写检查?
这儿有一个宏可以做到这一点. 这些应该放在你的.exrc文件中(后面我们将对.exrc
进一步讨论). 它是一个相当简单的宏. 它仅仅是调用ispell来处理当前文件.当然,你
的系统里面一定得有ispell这个程序. 使用它的时候,只需要敲个V键就行了(因为vi并
没有用V,所以V是一个比较合适的键)
\r\n<P>map V :w^M:!ispell % ^M:e!^M^M
第二个^M使你在拼写检查完之后无须敲回车就可以到vi中.
(译注, 在我的系统里,没有ispell,只有spell,我用它替换了ispell,工作的不错;还有,
^M不是两个字符,而是一个字符,通过^V^M敲进去的;另外,我个人认为第二个^M还是不要
的好,因为直接回到vi后你就无法看到拼写检查的结果了)
\r\n<P>3.8 - 我手头有一个硬拷贝的终端, 我还能用vi吗?
好了,好了. 我并认为有人会真的问这个问题.这个问题太偏了,我们大可不必理
它.(而且,它回答了一个非常普通的问题)
vi启动的时候处于一种特殊的模式下面,叫做\"开放模式\"; 在这种状态下,事情或多或少
的有些不同. 删除的字符在你面前显示成一\\\',vi会认为你的终端窗口只有一行. ^r
可以把当前行重新输出. z则把当前行周围的窗口重画一遍.
\r\n<P>3.9 - 好了,是不是处在开放模式下的原因呀?! 但是我现在没有用硬拷贝终端,它还是在
开放模式呀?
这儿的问题就是vi没有认出你用的终端的类型. 于是它假定你有的是个最烂的终端,
所以它决定依然处在开放模式下.这似乎没什么用处.因为没有多少人喜欢开放模式,但是
开放模式还是需要知道你的终端的一些最起码的信息的. 现在,我们来看如何解决这个
问题.我们有可能把它分成几种特殊的情形,但是,一般情况下, 这并没有用处. 如果你
直到你的终端的类, 你可以在UNIX提示符下面设置终端类型(在CSH及其变种下面,使用
命令setenv TERM &lt;终端类型&gt;;在SH及其变种下面,使用命令TERM=&lt;终端类型&gt;;
export TERM) 最好你能把上面的命令写在.profile文件或者.cshrc文件里面,这样你
一登录它就自动地给你设置好了.(当然,你应该知道如何使用ed,或者你能在UNIX提示符
下面设置好终端类型以便能使用vi, 这样你才有可能去编辑这些文件).如果你确实不
知道你地终端类型,试一试vt100.现在大多数地终端或者终端仿真器都能仿真vt100.
如果这还不能生效的话,你只好去找个高手来帮你了.
\r\n<P>4.0 - vi档案的在线帮助在哪儿?
有一个vi的FAQ,其中列出了vi档案的所有在线文件. 同时它还列出了这些文档
的镜象站点. 最主要的一个地址是alf.uib.no,但是这些文档在很多很多地地方
都保存着. vi-archive faq把它们都给列出来了.你在下载这些文件之前一定要
核对一下这个FAQ.因为很有可能有一个站点比去挪威的站点更近更快些.
一个镜象站点是cs.uwp.edu/pub/vi, 另一个是monu6.cc.monash.edu.au/pub/Vi,
这些站点上有很多有关vi的文件,还有一些vi的变种版本;当然,UCB版本的vi是
肯定有的, 还有许多的宏.
\r\n<P>5.0 - 好玩的vi诀窍,好玩的宏
这一节主要讲述一些无聊的诀窍和一些无聊的.事实上,任何vi的诀窍和宏我们
都欢迎,只要它们不是过分冗长. 如果有人向我建议而我也认为确实值得加的话,
我会考虑加进去的.
\r\n<P>5.1 - 好玩的vi诀窍
xp 删除光标下的字符,再把粘贴到后面去.换句话说,它交换了当前两个字符
的位置. ddp 和xp类似,不过是交换两行的位置.
uu 撤消和重复上次所做的修改.(这可以使你不改变什么东西就可以到你上次所
做的修改处)
\r\n<P>5.2 - 好玩的宏
和垂直上方的字符交换位置
map * kxjphxkP
\r\n<P>折行
map g $80|F r
(译注,我对这条宏表示疑问!)
\r\n<P>改变大多数单词的大小写
map v ywmno:s/./\\~/g
(译注,这条好象也不大对!)
\r\n<P>在当前的单词周围加上`和\'
map *` i`\'
在当前的单词周围加上\'和\'
map *\' i\'\'
在当前的单词周围加上\"和\"
map *\" i\"\"
(这几条也太无聊了吧--译注)
在当前的单词周围加上``和``
map! `` `\'
(咦,好象又有问题?--译注)
\r\n<P>从光标处把当前行分开,在下一行开头加上一个&gt;号(例如,引用USENET).如果加上了单词的折行
功能那么最后一个单词可能被折在第一行.
map g may0O`ay$:s/./ /g
(不对吧--译注)
\r\n<P>插入一个字符
map g i$^[r
\r\n<P>6.0 - 依字母顺序的vi快速参考
... 是指有些东西需要在命令之前或之后指明.这通常是说光标的移动键
(h,j,k,l,w,b等等)或者是指行号.
# (这里#代表一个数字) 执行n次后面的命令...
: 进入ex模式
) 下一句
( 上一句
} 下一段
{ 上一段
]] 下一节
[[ 上一节
0 行的开头
$ 行的末尾
^ 行的第一个非空白字符
+ 下一行的开头
- 上一行的开
(空格) 下一个字符
(回车) 下一行
/ 向前搜索
? 向后搜索
% 查找当前小(中,大)括号的匹配字符
, 逆向重复上一个f,F,t或T操作
; 重复上一个f,F,t或T操作
. 重复上一个操作
` 转到标记处
\' 转到标记所在行的开头
`` 查找前回到上一个做标记的地方
\'\' 查找前回到上一个做标记所在行的开头
~ 切换字符的大小写
\" 保存到寄存器中
!! 重复上一次SHELL命令
! 把后面的文本送给命令, 取代输出(例如, !}fmt把当前的段落
送给命令fmt处理,然后用fmt返回的东西替换输出.)
&gt;&gt; 右移当前段落一个移动宽度(shiftwidth)
&lt;&lt; 左移当前段落一个移动宽(shiftwidth)
&gt;% 从当前到匹配小(中,大)括号之间的文本右移
&lt;% 从当前到匹配小(中,大)括号之间的文本左移
(似乎漏了一个符号|, 移动到某一列----译注)
a 在当前位置之后添加
A 在当前行的末尾添加
^a 没有使用
b 上一个单词的开头
B 上一个单词的开头,忽略标点符号
^b 上移一屏
c 覆盖...
C 覆盖到行末尾
^c 终止插入模式,在命令模式没有用
d 删除...
D 删除到行末尾
\r\n<P>^d 下移半屏，如果在插入模式下则移到上一个移动宽度（ShiftTab)处
e 单词的末尾
E 单词的末尾,忽略标点符号
^e 屏幕下卷一行
f 查找...
F 向后查找...
^f 下移一屏
g 未用
G ...跳至[缺省是到文件末尾]
^g 显示状态栏
h 左移
H 屏幕上的第一行
^h 在插入模式下是退格,命令模式下是左移
i 在当前的位置前面插入
I 在本行的第一个非空白字符前面插入
^i 插入模式下是制表键,命令模式下未用
j 下移
J 把下一行合并到本行
^j 命令模式下是下移,插入模式下是建一个新行
k 上移
K 未用
^k 未用
l 右移
L 屏幕中的最后一行
^l 重绘屏
m 把当前位置标记到寄存器中
M 屏幕的中间行
^m 回车
n 重复上次查找
N 逆向重复上次查找
^n 命令模式下是下移
o 在当前行的下面建一个新行
O 在当前行的上面建一个新行
^o 未用
p 在当前行的下面粘贴
(译注--应为在当前位置的后面粘贴)
P 在当前行的上面粘贴
(译注--应为在当前位置的前面粘贴)
^p 命令模式下是上移
q 未用
Q 退出并且启动ex
^q 未用
r 覆盖当前的字符
R 在插入模式下一直覆盖字符
^r 在命令模式下面重绘屏幕
s 替换
S 替换整行
t 到...
T 向后到...
^t 移到下一个移动宽度(shifttab)处
u 撤消上一次操
U 撤消对本行的所有修改
^u 上移半屏
v 未用
V 未用
^v 未用
w 下一个单词的开头
W 下一个单词的开头,忽略标点符号
^w 命令模式下未用,在插入模式下是到上一个单词的开头处
x 删除当前字符
X 删除前一个字符
^x 未用
y 复制...
Y 复制整行
^y 屏幕上卷一行
z 重新配置当前行周围的屏幕
ZZ 保存之后退出
^z 未用
(译注--在命令模式下,^z执行了UNIX暂停操作)
6.1 - 命令模式的输入选项(:命令)
(注: 这不是一个规范的列表,, 我只是列出了一些最重要的命令)
:r &lt;文件&gt; 把&lt;文件&gt;读入到当前文档
:r !&lt;命令&gt; 把&lt;命令&gt;的输出插入到当前文本中
:nr &lt;文件&gt; 把&lt;文件&gt;插入到第n行
:!&lt;命令&gt; 运行&lt;命令&gt;,然后返回
:sh 转到SHELL
:so &lt;文件&gt; 读取&lt;文件&gt;,再执行文件里面的命令
(译注--文件中的命令应该都是一些ex命令)
 保存之后退出
:wq 保存之后退出
:l1,l2w &lt;文件&gt;把第l1和第l2行之间的文本写到&lt;文件&gt;中去,如果没有指定&lt;文件&gt;,
vi就假定是当前文件,如果没有指定l1,l2,就假定是整个文件(就成了:w)
:w &gt;&gt; &lt;文&gt; 添加到&lt;文件&gt;末尾. 也可以使用行号
:w! 覆盖当前文件
:q 退出
:q! 不存盘就退出
:e &lt;文件&gt; 不离开vi编辑&lt;文件&gt;
:e! 重新编辑当前文件,忽略所有的修改
:n 编辑下一个文件
:e +n &lt;文件&gt; 从第n行开始编辑&lt;文件&gt;,如果超过了末尾,就从末尾开始编辑
:e# 编辑替换文件(如果使用了命令:e&lt;文件&gt;,替换文件就指的是原始文件)
:args 显示所有要编辑的文件
:rew 重新回到第一个编辑的文档
:map m n 创建一个宏(使 m 做 n)
:map! m n 创建一个插入模式的宏(使 m 做 n)
:unmap m 删除宏m
:unmap! m 删除插入模式的宏m
:ab &lt;1&gt; &lt;2&gt; 缩写,敲&lt;1&gt;的时候&lt;2&gt;取代
:unab &lt;1&gt; 取消缩写&lt;1&gt;
:set &lt;选项&gt; 设置&lt;选项&gt;...
\r\n<P>6.2 - 设置选项(set) 显示所有的制
magic magic 可以使用更多的正规表达式
mesg mesg 允许向终端发送消息
number (nu) nonumber 显示行号
open open 允许开放和可视化
optimize (opt) optimize 优化吞吐量,打印时不发回车
paragraphs= (para=) IPLPPPQPPLIbp 设置{ &amp; }的分界符
prompt prompt 命令模式下的输入给出:的提示符
readonly (ro) noro 除非用!号否则不准保存文件
redraw noredraw 当编辑的时候重绘屏幕
remap remap 允许宏指向其他的宏
report= 5 如果影响的行数&gt;这个数的话就报告
scroll 1/2 window 下卷屏幕时滚动屏幕的数目,
同样这也z命令输出的行数(z 输出2倍滚屏的大小)
sections= SHNHH HU 定义节的末尾(当使用命令[[ 和 ]] 时)
shell= (sh=) /bin/sh 缺省的SHELL,如果设置了环境变量SHELL的话,就使用变量
shiftwidth= (sw=) 8 当使用移动(shift)命令时移动的字符数
showmatch (sm) nosm 显示{, }, (, , [, 或者 ] 的匹配情况
showmode noshowmode 显示你处在什么模式下面
slowopen (slow) 插入之后不要立刻更新显示
tabstop= (ts=) 8 设置制表停止位(tabstop)的长度
taglength= (tl=) 0 重要标记的字符个数(0表示所有的字符)
tags= tag, /usr/lib/tags 定义包含标记的文件路
term= 设置终端类型
terse noterse 显示简短的错误信息
timeout (to) timeout 一秒钟后键盘映射超时
ttytype= 设置终端类型
warn warn 显示\"No write since last change\"信息
window= (w=) 可视模式下窗口的行数
wrapmargin= (wm=) 0 右边距,大于0的话最右边的单词将折行,留出n个空白位置
wrapscan (ws) ws 查找到文件尾后再重头开始
writeany (wa) nowa 可以保存到任意一个文件去
\r\n<P>(译注--这些选项在各种vi版本中都基本上大同小异,以SunOS带的vi为例,它没有这里列
出来的open选项, scroll的参数值也不同,还多出来一些选项,如flash,modelines,
novice,tagstack等等)
\r\n<P>7.0 - 建立 .exrc文件
所有命令输入模式下的命令(即 :命令)都可以在.exrc文件中使用,在.exrc中的命令在


: empty register \"q\"
----------------------------------------
\" Useful tricks
\"<A href=\"mailto:ayy@a\"><FONT color=#0000ff>ayy@a</FONT></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : execute \"Vim command\" in a text file
yy@\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : same thing using unnamed register
u@.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : execute command JUST typed in
----------------------------------------
\" Get output from other commands (requires external programs)
:r!ls.exe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : reads in output of ls
!!date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : same thing (but replaces/filters current line)
\" Sorting with external sort
:%!sort -u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : use an external program to filter content
:\'a,\'b!sort -u&nbsp;&nbsp; : use an external program to filter content
!1} sort -u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : sorts paragraph (note normal mode!!)
----------------------------------------
\" Multiple Files Management (Essential)
:bn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : goto next buffer
:bp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : goto previous buffer
:wn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : save file and move to next (super)
:wp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : save file and move to previous
:bd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : remove file from buffer list (super)
:bun&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Buffer unload (remove window but not from list)
:badd file.c&nbsp;&nbsp;&nbsp;&nbsp; : file from buffer list
:b 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : go to buffer 3
:b main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : go to buffer with main in name eg main.c (ultra)
:sav php.html&nbsp;&nbsp;&nbsp; : Save current file as php.html and \"move\" to php.html
:sav! %&lt;.bak&nbsp;&nbsp;&nbsp;&nbsp; : Save Current file to alternative extension (old way)
:sav! %:r.cfm&nbsp;&nbsp;&nbsp; : Save Current file to alternative extension
:sav %:s/fred/joe/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : do a substitute on file name
:sav %:s/fred/joe/:r.bak2&nbsp;&nbsp;&nbsp; : do a substitute on file name &amp; ext.
:!mv % %:r.bak&nbsp;&nbsp; : rename current file (DOS use Rename or DEL)
:e!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : return to unmodified file
:w c:/aaa/%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : save file elsewhere
:e #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : edit alternative file (also cntrl-^)
:rew&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : return to beginning of edited files list (:args)
:brew&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : buffer rewind
:sp fred.txt&nbsp;&nbsp;&nbsp;&nbsp; : open fred.txt into a split
:sball,:sb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Split all buffers (super)
:scrollbind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : in each split window
:map&nbsp;&nbsp; &lt;F5&gt; :ls&lt;CR&gt;:e # : Pressing F5 lists all buffer, just type number
:set hidden&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Allows to change buffer w/o saving current buffer
----------------------------------------
\" Quick jumping between splits
map &lt;C-J&gt; &lt;C-W&gt;j&lt;C-W&gt;_
map &lt;C-K&gt; &lt;C-W&gt;k&lt;C-W&gt;_
----------------------------------------
\" Recording (BEST TIP of ALL)
qq&nbsp; # record to q
your complex series of commands
q&nbsp;&nbsp; # end recording
@q to execute
@@ to Repeat
5@@ to Repeat 5 times
\" editing a register/recording
\"qp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :display contents of register q (normal mode)
&lt;ctrl-R&gt;q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :display contents of register q (insert mode)
\" you can now see recording contents, edit as required
\"qdd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :put changed contacts back into q
@q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :execute recording/register q
\" Operating a Recording on a Visual BLOCK
1) define recording/register
qq:s/ to/ from/g^Mq
2) Define Visual BLOCK
V}
3) hit : and the following appears
:\'&lt;,\'&gt;
4)Complete as follows
:\'&lt;,\'&gt;norm @q
----------------------------------------
\"combining a recording with a map (to end up in command mode)
nnoremap ] @q:w!&lt;bar&gt;bd
----------------------------------------
\" Visual is the newest and usually the most intuitive editing mode
\" Visual basics
v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : enter visual mode
V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : visual mode whole line
&lt;C-V&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : enter VISUAL BLOCK mode
gv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : reselect last visual area (ultra)
o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : navigate visual area
\"*y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : yank visual area into paste buffer
V%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : visualise what you match
V}J&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Join Visual block (great)
V}gJ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Join Visual block w/o adding spaces
----------------------------------------
\" Delete first 2 characters of 10 successive lines
0&lt;c-v&gt;10j2ld
----------------------------------------
\" how to copy a set of columns using VISUAL BLOCK
\" visual block (AKA columnwise selection) (NOT BY ordinary v command)
&lt;C-V&gt; then select \"column(s)\" with motion commands (win32 &lt;C-Q&gt;)
then c,d,y,r etc
----------------------------------------
\" how to overwrite a visual-block of text with another such block
Pick the first block: ctrl-v move \"ay
Pick the second block: ctrl-v move c ctrl-o \"aP &lt;esc&gt;
----------------------------------------
\" _vimrc essentials
:set incsearch : jumps to search word as you type (annoying but excellent)
:set wildignore=*.o,*.obj,*.bak,*.exe : tab complete now ignores these
:set shiftwidth=3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : for shift/tabbing
:set vb t_vb=\".&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : set silent (no beep)
:set browsedir=buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Maki GUI File Open use current directory
----------------------------------------
\" launching Win IE
:nmap ,f :update&lt;CR&gt;:silent !start c:\\progra~1\\intern~1\\iexplore.exe <A href=\"file://%:p<CR/\"><FONT color=#0000ff>file://%:p&lt;CR</FONT></A>&gt;
:nmap ,i :update&lt;CR&gt;: !start c:\\progra~1\\intern~1\\iexplore.exe &lt;cWORD&gt;&lt;CR&gt;
----------------------------------------
\" FTPing from VIM
cmap ,r&nbsp; :Nread <A href=\"ftp://209.51.134.122/public_html/index.html\"><FONT color=#0000ff>ftp://209.51.134.122/public_html/index.html</FONT></A>
cmap ,w&nbsp; :Nwrite <A href=\"ftp://209.51.134.122/public_html/index.html\"><FONT color=#0000ff>ftp://209.51.134.122/public_html/index.html</FONT></A>
gvim <A href=\"ftp://www.somedomain.com/index.html\"><FONT color=#0000ff>ftp://www.somedomain.com/index.html</FONT></A> # uses netrw.vim
----------------------------------------
\" appending to registers (use CAPITAL)
\" yank 5 lines into \"a\" then add a further 5
\"a5yy
10j
\"A5yy
----------------------------------------
[I&nbsp;&nbsp;&nbsp;&nbsp; : show lines matching word under cursor &lt;cword&gt; (super)
----------------------------------------
\" Conventional Shifting/Indenting
:\'a,\'b&gt;&gt;
\" visual shifting (builtin-repeat)
:vnoremap &lt; &lt;gv
:vnoremap &gt; &gt;gv
\" Block shifting (magic)
&gt;i{
&gt;a{
\" also
&gt;% and &lt;%
----------------------------------------
\" Redirection &amp; Paste register *
:redir @*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : redirect commands to paste buffer
:redir END&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : end redirect
:redir &gt;&gt; out.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : redirect to a file
\" Working with Paste buffer
\"*yy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : yank to paste
\"*p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : insert from paste buffer
\" yank to paste buffer (ex mode)
:\'a,\'by*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Yank range into paste
:%y*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Yank whole buffer into paste
:.y*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Yank Current line to paster
\" filter non-printable characters from the paste buffer
\" useful when pasting from some gui application
:nmap &lt;leader&gt;p :let @* = substitute(@*,\'[^[:print:]]\',\'\',\'g\')&lt;cr&gt;\"*p
----------------------------------------
\" Re-Formatting text
gq}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Format a paragraph
gqap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Format a paragraph
ggVGgq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Reformat entire file
Vgq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : current line
\" break lines at 70 chars, if possible after a ;
:s/.\\{,69\\};\\s*\\|.\\{,69\\}\\s\\+/&amp;\\r/g
----------------------------------------
\" Operate command over multiple files
:argdo %s/foo/bar/e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : operate on all files in :args
:bufdo %s/foo/bar/e
:windo %s/foo/bar/e
:argdo exe \'%!sort\'|w!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : include an external command
----------------------------------------
\" Command line tricks
gvim -h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : help
ls | gvim -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : edit a stream!!
cat xx | gvim - -c \"v/^\\d\\d\\|^[3-9]/d \" : filter a stream
gvim -o file1 file2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : open into a split
\" execute one command after opening file
gvim.exe -c \"/main\" joe.c&nbsp; : Open joe.c &amp; jump to \"main\"
\" execute multiple command on a single file
vim -c \"%s/ABC/DEF/ge | update\" file1.c
\" execute multiple command on a group of files
vim -c \"argdo %s/ABC/DEF/ge | update\" *.c
\" remove blocks of text from a series of files
vim -c \"argdo /begin/+1,/end/-1g/^/d | update\" *.c
\" Automate editing of a file (Ex commands in convert.vim)
vim -s \"convert.vim\" file.c
#load VIM without .vimrc and plugins (clean VIM)
gvim -u NONE -U NONE -N
\" Access paste buffer contents (put in a script/batch file)
gvim -c \'normal ggdG\"*p\' c:/aaa/xp
\" print paste contents to default printer
gvim -c \'s/^/\\=@*/|hardcopy!|q!\'
\" gvim\'s use of external grep (win32 or *nix)
:grep somestring *.php&nbsp;&nbsp;&nbsp;&nbsp; : creates a list of all matching files
\" use :cn(ext) :cp(rev) to navigate list
:h grep
----------------------------------------
\" GVIM Difference Function (Brilliant)
gvim -d file1 file2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : vimdiff (compare differences)
dp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : \"put\" difference under cursor to other file
do&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : \"get\" difference under cursor from other file
----------------------------------------
\" Vim traps
In regular expressions you must backslash + (match 1 or more)
In regular expressions you must backslash | (or)
In regular expressions you must backslash ( (group)
In regular expressions you must backslash { (count)
/fred\\+/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : matches fred/freddy but not free
/\\(fred\\)\\{2,3}/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : note what you have to break
----------------------------------------
\" \\v or very magic (usually) reduces backslashing
/codes\\(\\n\\|\\s\\)*where&nbsp; : normal regexp
/\\vcodes(\\n|\\s)*where&nbsp;&nbsp; : very magic
----------------------------------------
\" pulling objects onto command/search line (SUPER)
&lt;C-R&gt;&lt;C-W&gt; : pull word under the cursor into a command line or search
&lt;C-R&gt;&lt;C-A&gt; : pull WORD under the cursor into a command line or search
&lt;C-R&gt;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pull small register (also insert mode)
&lt;C-R&gt;[0-9a-z]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pull named registers (also insert mode)
&lt;C-R&gt;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pull file name (also #) (also insert mode)
&lt;C-R&gt;=somevar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : pull contents of a variable (eg :let sray=\"ray[0-9]\")
----------------------------------------
\" manipulating registers
:let @a=@_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : clear register a
:let @a=\"\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : clear register a
:let @*=@a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : copy register a to paste buffer
map&nbsp;&nbsp; &lt;f11&gt; \"qyy:let @q=@q.\"zzz\"
----------------------------------------
\" help for help (USE TAB)
:h quickref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : VIM Quick Reference Sheet (ultra)
:h tips&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Vim\'s own Tips Help
:h visual&lt;C-D&gt;&lt;tab&gt;&nbsp;&nbsp;&nbsp;&nbsp; : obtain&nbsp; list of all visual help topics
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Then use tab to step thru them
:h ctrl&lt;C-D&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : list help of all control keys
:helpg uganda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : grep HELP Files use :cn, :cp to find next
:h :r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : help for :ex command
:h CTRL-R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : normal mode
:h /\\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : what\'s \\r in a regexp (matches a &lt;CR&gt;)
:h <A href=\"file://zs/\"><FONT color=#0000ff>\\\\zs</FONT></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : double up backslash to find \\zs in help
:h i_CTRL-R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : help for say &lt;C-R&gt; in insert mode
:h c_CTRL-R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : help for say &lt;C-R&gt; in command mode
:h v_CTRL-V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : visual mode
:h tutor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : VIM Tutor
&lt;C-[&gt;, &lt;C-T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Move back &amp; Forth in HELP History
gvim -h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : VIM Command Line Help
----------------------------------------
\" where was an option set
:scriptnames&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : list all plugins, _vimrcs loaded (super)
:verbose set history?&nbsp;&nbsp; : reveals value of history and where set
:function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : list functions
:func SearchCompl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : List particular function
----------------------------------------
\" making your own VIM help
:helptags /vim/vim64/doc&nbsp; : rebuild all *.txt help files in /doc
:help add-local-help
----------------------------------------
\" running file thru an external program (eg php)
map&nbsp;&nbsp; &lt;f9&gt;&nbsp;&nbsp; :w&lt;CR&gt;:!c:/php/php.exe %&lt;CR&gt;
map&nbsp;&nbsp; &lt;f2&gt;&nbsp;&nbsp; :w&lt;CR&gt;:!perl -c %&lt;CR&gt;
----------------------------------------
\" capturing output of current script in a separate buffer
:new | r!perl #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : opens new buffer,read other buffer
:new! x.out | r!perl #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : same with named file
:new+read!ls
----------------------------------------
\" create a new buffer, paste a register \"q\" into it, then sort new buffer
:new +put q|%!sort
----------------------------------------
\" Inserting DOS Carriage Returns
:%s/$/\\&lt;C-V&gt;&lt;C-M&gt;&amp;/g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; that\'s what you type
:%s/$/\\&lt;C-Q&gt;&lt;C-M&gt;&amp;/g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; for Win32
:%s/$/\\^M&amp;/g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; what you\'ll see where ^M is ONE character
----------------------------------------
\" automatically delete trailing Dos-returns,whitespace
autocmd BufRead * silent! %s/[\\r \\t]\\+$//
autocmd BufEnter *.php :%s/[ \\t\\r]\\+$//e
----------------------------------------
\" perform an action on a particular file or file type
autocmd VimEnter c:/intranet/note011.txt normal! ggVGg?
autocmd FileType *.pl exec(\'set fileformats=unix\')
----------------------------------------
\" Retrieving last command line command for copy &amp; pasting into text
i&lt;c-r&gt;:
\" Retrieving last Search Command for copy &amp; pasting into text
i&lt;c-r&gt;/
----------------------------------------
\" more completions
&lt;C-X&gt;&lt;C-F&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :insert name of a file in current directory
----------------------------------------
\" Substituting a Visual area
\" select visual area as usual (:h visual) then type :s/Emacs/Vim/ etc
:\'&lt;,\'&gt;s/Emacs/Vim/g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : REMEMBER you dont type the \'&lt;.\'&gt;
gv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Re-select the previous visual area (ULTRA)
----------------------------------------
\" inserting line number into file
:g/^/exec \"s/^/\".strpart(line(\".\").\"&nbsp;&nbsp;&nbsp; \", 0, 4)
:%s/^/\\=strpart(line(\".\").\"&nbsp;&nbsp;&nbsp;&nbsp; \", 0, 5)
:%s/^/\\=line(\'.\'). \' \'
----------------------------------------
#numbering lines VIM way
:set number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : show line numbers
:map &lt;F12&gt; :set number!&lt;CR&gt;&nbsp;&nbsp;&nbsp
